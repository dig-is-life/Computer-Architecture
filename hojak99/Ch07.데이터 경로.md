# 데이터 경로
데이터 경로의 의미와 두 가지 구현 방식에서 데이터의 흐름을 살펴본다.

## 데이터 경로의 이해
###  데이터 경로
`데이터 경로` : 명령어를 실행할 때 프로세서가 명렁어의 정의에 따라 데이터를 경유시키는 경로.

데이터는 입력장치, 프로세서, 메모리, 출력장치 등 컴퓨터의 모든 구성 요소를 경유한다. 하지만 실행 프로그램은 이미 메모리에 적재되어 있으므로, 입출력 명령이 아니라면 명령어에 대한 데이터 경로는 프로그램 계수기(PC), 레지스터 파일, 연산장치(ALU), 메모리 등으로 구성된다.

> 자세한 내용은 236쪽 참고

### 데이터 경로의 두 가지 방식
데이터 경로는 크게 `단일 사이클 방식` 과 `다중 사이클 방식` 으로 구현할 수 있다.

단일, 다중 사이클 방식은 각각 한 번, 여러 번 돈다고 생각하면 된다.

----

16비트 덧셈장치를 예를 들 수 있다.

단일 사이클 덧셈 장치는 한 사이클 동안 16개의 전가산기를 사용해 16비트를 모두 더한다.

하지만 다중 사이클 덧셈 장치는 하나의 전가산기를 열어섯 번 반복하여 1비트씩 연산할 결과를 차례대로 저장한다. 즉 16사이클이 걸린다

> 자세한 내용 237페쪽 참고

하나의 전가산기에 대한 지연 시간이 1ns 고 배선, 플립플롭에 의한 지연 시간은 무시한다고 가정했을 때 단일 사이클 덧셈 장치는 데이터 16개의 전가산기를 경유하는데 한 사이클이 소요되므로 클록 사이클 시간이 16ns 이다. 

다중 사이클 덧셈장치는 한 사이클동안 하나의 전가산기만 경유하기 때문에 클록 사이클 시간이 1ns 이다. 그렇지만 16사이클이 걸리게 된다.

즉 두 장치의 덧셈 연산에 대한 지연 시간은 다음과 같다.

`CPU 실행 시간 = 명령어 개수 X 평균 CPI X 사이클 시간`

다중 사이클 방식 : (명령어 1개) X (1 사이클/명령어) X (16ns/사이클)
다중 사이클 방식 : (명령어 1개) X (16 사이클/명령어) X (1ns/사이클)

지연 시간이 같지만 플립플롭에 대한 지연 시간 등을 무시했기에 실제는 다를 수 있다.

### 명렁어 실행과 데이터 경로
기본 아키텍처로 사용할 picoMIPS 가 지원하는 명령어의 실행과정을 여러 단계로 나눠 살펴본다.

### picoMIPS 의 명령어 형식
picoMIPS 는 다음과 같이 R-형식, I-형식, J-형ㅎ식의 세 가지 명령어 형식을 지원하며, 명령어 형식은 연산 부호에 의해 결정된다.

R-형식 : 레지스터 2개를 사용하여 연산장치에서 처리 후 연산 결과를 다른 레지스터에 저장하는 명령어
I-형식 : 메모리 참조, 상수 피연산자를 가진 연산, 조건 분기 등을 수행하는 명령어
J-형식 : 무조건 분기를 수행하는 명령어

모든 명령어는 16비트로 구성돼 있지만 필드 개수는 다르다.

> 자세한 내용은 239쪽 참고

### picoMIPS 명령어의 단계적 실행
picoMIPS의 명령어 실행 과정을 단계적으로 나눠보자.

##### 명령어 인출
모든 명령어는 명령어 형식과 상관 없이 다음과 같은 작업을 통해 실행한 명령어를 인출한다.

- PC가 가리키는 메모리의 내용인 명령어를 읽는다
- PC가 다음 명령어를 가리키도록 PC 의 내용을 갱신한다

##### 명령어 해독 및 레지스터 읽기
실행할 명령어를 인출하면 제어장치가 명령어의 연산 부호를 해독할 수 있다. 이렇게 연산 부호를 해독하는 동안 명령어를 구성 요소별로 분해하여 다음과 같은 작업을 수행할 수 있다.

- R-형식 명령어 : 3개의 레지스터 주소를 추출하고, 그 중 2개의 레지스터 주소(rs와 rt)를 이용하요 레지스터의 내용을 읽는다
- I-형식 명령어 : 2개의 레지스터 주소를 추출하고, 그 중 1개의 레지스터 주소(rs) 또는 2개의 레지스터 주소(rs, rt) 를 이용하여 레지스터 내용 읽는다
- J-형식 명령어 : 레지스터의 내용을 읽을 필요가 없다.

명령어 형식을 모르더라도 R-형식 명령어처럼 2개의 레지스터 내용을 읽어도 문제가 없다. 레지스터에서 데이터 읽는 것은 프로세서의 상태와 관계가 없기 때문이다. I-형식이나 J-형식 명령어라고 해도 문제가 되지 않는다.

단일 사이클 방식이나 다중 사이클 방식에 따라 다르지만 이 외에도 명령어를 해독하는 동안 분기 명령어를 위해 미리 분기할 주소도 계산할 수 잇다.

##### 명령어 종류별 고유 과정
명령어 인출과 레지스터 읽기 과정이 끝나면 이미 제어장치가 명령어의  연산 부호를 해독한 상태이다. 이제 명령어릐 종류에 따라 다음과 같이 산술연산 및 논리연산, 메모리 참조, 분기연산 등을 수행할 수 있다.

- 산술연산 및 논리연산 : ALU 를 이용하여 연산을 수행한 후 결과를 레지스터에 저장한다.
- 메모리 참조 : ALU 를 이용하여 메모리 주소를 계산한다. 메모리와 레지스터 사이에 데이터를 이동한다.
- 조건 분기 : 조건의 만족 여부에 따라 분기 주소로 PC 를 갱신한다.
- 무조건 분기 : PC 를 조건 없이 분기 주소로 갱신한다.

### 데이터 경로의 기본 골격
모든 명려어는 명령어 인출과 해독이라는 공통적인 과정을 거치고 각 명령어 별로 고유의 연산이나 메모리 접근 혹은 레지스터 쓰기 등을 수행한다. 데이터 경로의 기본적인 골격을 두가지 방식으로 구성해보자.

##### 단일 사이클 방식
메모리 접근은 명령어를 인출, 데이터 적재-저장 할 때도 필요하다. 단일 사이클 방시의 경우, 명령어가 한 사이클 동안 전체 데이터 경로를 사용하기 때문에 데이터 경로에 포함된 동일한 자원을 다시 사용할 수 없다. 

그래서 한 사이클 동안 명령어 인출, 데이터 읽고 쓰려면 메모리에 두 번 접근해야 하므로 메모리를 2개로 분할해야 한다. 그러나 실제 프로세서는 캐시 메모리에 먼저 접근하기 때문에 캐시 메모리를 명령어 캐시와 데이터 캐시로 분할하여 데이터 경로로 사용한다.

단일 사이클 방식은 명령어 인출 동안 PC 값을 갱신하기 위해 ALU  를 사용하고, 명령어 해독 후에도 덧뺄셈과 같은 연산을위해 ALU 를 사용해한다. 그래서 PC 값을 갱신할 때 ALU 를 사용하지 않고 별도의 PC 갱신 장치를 사용하도록 해야 한다.

> 자세한 내용은 242쪽과 그림 7-5 참고

##### 다중 사이클 방식
다중 사이클 방식은 여러 사이클을 사용하여 명령어를 실행하고 각 사이클마다 명령어가 데이터 경로를 다시 사용한다. 그래서 동일한 사이클이 아니라면 명령어가 데이터 경로에 포함된 컴퓨터 자원을 여러 번 사용할 수 있다.

그래서 다중 사이클 방식은 단일 사이클 방식과 달리 메모리 2개로 분할하고, ALU 외에 PC 갱신장치도 필요 없다.

그러나 다중 사이클 방식은 사이클마다 처리한 결과를 다음 사이클에서 사용할 수 있도록 임시 저장소가 필요하다. 명령어 레지스터(IR) 과 데이터 레지스터(DR) 은 메모리로부터 읽은 명령어와 데이터를 보관하기 위한 임시 저장소이다.

> 자세한 내용은 243 쪽 그림 7-6 참고

## 단일 사이클 방식의 명령어 실행
이 부분은 그림으로 설명한 부분이 대부분이기 때문에 책을 봐야 한다.

> 244쪽~247쪽


## 다중 사이클 방식의 명령어 실행
단일 사이클 방식 데이터 경로에서 명령어의 실행 과정을 단계 별로 나타냈으나 실제 한 사이클에서 실행된다.

이 절에서는 R-형식의 덧셈 명령어와 I-형식의 적재 명령어가 실행될 때 다중 사이클 방식의 데이터 경로에서 어떻게 데이터가 흘러가는지 단계적으로 살펴보자.

### 명령어 인출
단일 사이클 방식과 달리 다중 사이클 방식은 별도의 PC 갱신 장치가 필요 없다. PC 를 갱신하는 명령어 인출 과정과 ALU 를 사용하는 명령어 고유 과정이 다른 사이클에서 수행되고 ALU 를 사용하여 PC 를 갱신할 수 있기 때문이다.

> 자세한 내용은 그림 7-17 참고

### 명령어 해독과 레지스터 읽기
다중 사이클 방식의 명령어 해독과 레지스터 읽기는 단일 사이클 방식과 유사하다.

한 사이클에 명령어를 해독하는 동안 레지스터 파일에 접근해 조건 분기 명령어를 위한 메모리 주소도 계산 후 임시 저장소에 저장한다. 다음 사이클에서 임시 저장소의 내용이 필요 없다면 무시한다.

> 자세한 내용은 그림 7-18 참고

### 덧셈 명령어 실행
> 자세한 내용은 7-19 참고

### 적재 명령어 실행
> 자세한 내용은 254 ~ 256 쪽 참고

## 데이터 경로의 구체화와 성능 비교
지금까지 구성한 데이터 경로의 기본 골격을 구체화하고, 두 가지 방식 데이터 경로의 성능을 비교해보도록 한다.

### 데이터 경로의 구체화
데이터 경로의 기본 골격을 구체화하려면 다음과 같은 3가지 문제점을 해결해야 한다. 또한 단일 사이클 방식은 PC 갱신 장치도 구체적으로 완성해야 한다.

##### 문제점 1
데이터 경로의 기본 골격은 다음과 같은 경우에 하나의 입력 단자에 다수의 입력이 주어져 충돌이 발생하는데 이를 멀티플렉서로 해결할 수 있다.

- 단일 사이클 방식에서 ALU 하단 입력 단자에 2개의 데이터가 입력되는 경우
- 다중 사이클 방식에서 ALU 의 상단 및 하단 입력 단자에 각각 2개와 4개의 데이터가 입력되는 경우
- 다중 사이클 방식에서 메모리 주소 입력 단자에 2개의 주소가 입력되는 경우
- 단일 및 다중 사이클 방식에서 레지스터 데이터 입력 단자에 2개의 데이터가 입력되는 경우
- 다중 사이클 방식에서 PC 입력 단자에 2개의 주소가 입력되는 경우
- 단일 및 다중 사이클 방식의 레지스터 파일에서 세 번째 주소 단자에 명령어의 rt 필드나 rd 필드가 모두 입력되는 경우

##### 문제점 2
picoMIPS 아키텍처의 ALU 는 16 비트의 데이터를 연산하지만, 명령어 레지스터에서 추출된 addr 필드와 imm 필드는 각각 12비트, 6비트 데이터이다. 이 문제는 산술 연산이라면 부호 확장을, 논리연산이라면 0-확장을 위한 논리회로를 사용해 해결 할 수 있다

##### 문제점 3
메모리는 기본 주소 단위로 바이트를 사용하는데 분기 명령어나 적재 및 저장 명령어의 경우, addr 필드와 imm 필드가 워드 단위의 주소이다. 따라서 바이트 단위의 주소로 메모리에 접근하려면 시프터를 사용하여 두 필드를 1바이트 왼쪽으로 시프트해야 한다.

> 자세한 내용은 258~260 페이지 참고

### 단일 사이클 방식과 다중 사이클 방식의 성능 비교
데이터 경로를 구성하는 각종 기능 장치의 지연 시간은 다음과 같다고 가정한다.

- 메모리 : 2ns
- 레지스터 파일 : 1ns
- 연산장치 : 2ns
- 멀티플렉서, 부호확장기, 시프터 등 : 0ns

명령어를 해독하는 시간은 레지스터 접근과 완전히 중첩되므로 추가적인 지연 시간이 발생하지 않는다. 그리고 작업 부하의 평균적인 명령어 배합은 다음과 같다고 가정한다.

- R-형식 명령어 : 44%
- 적재 명령어 : 24%
- 저장 명령어 : 12%
- 분기 명령어 : 20%

이러한 네거지 유형의 명령어를 실행할 때 데이터 경로, 단일 사이클 방식의 지연 시간, 다중 사이클 방식의 사이클 개수는 다음과 같다.


|명령어 종류|데이터경로|단일사이클 방식의 지연시간|다중 사이클 방식의 사이클 개수|
|----------|---------|-----------------------|--------------------------|
|R-형식|메모리->레지스터 파일->연산장치->레지스터 파일|6ns|4|
|적재|메모리->레지스터 파일->연산장치->메모리->레지스터 파일|8ns|5|
|저장|메모리->레지스터 파일->연산장치->메모리|7ns|4|
|분기|메모리->레지스터 파일->연산장치->PC|6ns|4|

일반적으로 적재 명령어는 저장 명령어보다 지연 시간이 짧다. 여기서는 메모리의 쓰기, 읽기에 대한 지연 시간이 동일하다고 가정했기 때문에 적재 명령어의 지연 시간이 길어진다. 그러나 성능 분석에는 문제 없다.


