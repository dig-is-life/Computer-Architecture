# 컴퓨터의 발전과 성능

## 컴퓨터의 세대별 발전

반도체의 획기적인 발전에 따라 컴퓨터 환경은 크게 진화함. 

컴퓨터 : 전자회로를 이용해 다양한 종류의 데이터를 처리하는 장비.

그렇다면 각 컴퓨터의 세대별 특징을 살펴보도록 하자.

컴퓨터의 세대 | 주요 소자 | 기억장치 | 특징
------------ | -------- | -------- | ---
0세대 컴퓨터 | 기계적 릴레이 | 금속 기어, 카드 | -
1세대 컴퓨터 (~1950년대 후반) | 진공관 | 자기드럼 | 하드웨어 개발 중점. 부피 크고 전력 소모 많음. 
2세대 컴퓨터 (~1960년대 초반) | 트랜지스터 | 자기코어 | 고급언어 등장
3세대 컴퓨터 (~1070년대 중반) | SSI,MSI | RAN, ROM | 운영체제 개발, 다중 프로그래밍, 고급언어 활용
4세대 컴퓨터 (~2000년대) | LSI, VLSI | SRAM, DRAM | 객체지향언어 사용, 개인용 컴퓨터 등장, 병렬 처리 기능 강화
5세대 컴퓨터 (2000년대 중반 ~) | VLSI, ULSI, GLSI, SoC | SDRAM, DRAM, flash | 비노이만 구조 추구, 멀티코어 사용, 유비쿼터스 컴퓨팅 환경 조성

----

3세대 이휴부터 하나의 프로세서에 포함된 논리소자의 수를 기준으로 분류하는데, 다수의 트랜지스터를 하나의 칩으로 집약한 집적회로를 기반으로 한다. 아래의 표를 참고하면서 보자.

집적회로 | 트랜지스터의 수 | 예
------- | -------------- | ---
SSI | ~ 100 | 기본적인 게이트 기능과 플립플롭
MSI | ~ 1,000 | 인코더, 디코더, 카운터, 레지스터, 멀티플렉서, 디멀티플렉서
LSI | ~ 10,000 | 기억장치
VLSI | ~ 100,000 | 대규모 기억장치, 마이크로프로세서
ULSI | 1,000,000 | 대규모 기억장치, 마이크로프로세서

---

## 현대 컴퓨터 발전의 지표
해당 챕터에서는 폰노이만 모델, 무어의 법칙 등을 살펴본다.

### 폰노이만 아키텍처
`폰노이만 아키텍처`란 프로그램을 `저장`하고 `변경`할 수 있는 프로그램 `내장식` 컴퓨터 모델이다. 즉, 컴퓨터 내부에 프로그램과 데이터를 저장하여 컴퓨터가 필요한 내용을 순서에 따라 인출하고 해독하도록 할 수 있다.

폰노이만 아키텍처는 이 이후에 개발된 모든 범용 컴퓨터의 기본 모델이다.

폰노이만 아키텍처 이전에는 `고정결선식 프로그램 컴퓨터` 방식을 사용했다.
간단하게 이야기하자면 미리 정의된 기능을 물리적, 하드웨어적으로 설계한 기계이다. 그래서 저장, 변경할 수 없고 주어진 기능만 처리 가능하다. 또한, 기능을 수정하거나 확대하려면 기계 내부를 수정해야 한다.

폰노이만 아키텍처로 개발된 `프로그램 내장식 컴퓨터` 방식은 프로그램 자체와 프로그램에서 사용하는 데이터를 동일한 형태로 메모리에 저장할 수 있는 구조이다.

그렇기 때문에 하드웨어에 대한 전문적 지식이 없어도 원하는 작업을 프로그래밍 할 수 있다.

폰노이만 아키텍처는 다음과 같이 구성된다.
 - CPU : 명령어를 해석하고 데이터를 처리한다.
 - 메모리 : 명령어와 데이터를 저장한다.
    - 순차적인 주소를 가진 워드로 구성
    - 명령어와 데이터를 구분 없이 저장
    - 워드는 인출될 때 컴퓨터 상태에 따라 명령어나 데이터로 해석
 - 입출력장치

이 때 CPU 와 메모리 사이에 발생하는 트래픽이 성능에 큰 영향을 미쳐 지연 현상을 발생하는 것을 `폰노이만 병복` 이라고 한다.

> 추가적으로 폰노이만 모델의 성능을 개선하기 위해 수정한 구조를 `하버드 아키텍처` 라고 한다. 메모리를 2개로 분할해 명령어와 데이터를 별도의 메모리에 저장. CPU 의 제어장치, 연산장치를 별로의 버스로 각각 연결해 병렬로 인출

### 무어의 법칙
무어의 법칙 : 단일 마이크로칩에 포함된 트랜지스터의 수가 18개월마다 약 2배씩 증가한다는 것을 의미.

---

## 컴퓨터의 성능
컴퓨터의 속도나 효율성 등을 `컴퓨터의 성능` 이라고 한다. 

### 성능의 정의
보통 `프로그램 응답 시간`과 `처리율`은 완전히 별개의 요소가 아니라, 하나를 향상하면 다른 것도 성능이 향상된다.
여기서 `프로그램 응답 시간` 은 하나의 프로그램을 처리하는데 소요되는 시간을 의미한다.

이 응답 시간에는 여러가지 응답 시간이 포함 돼 있다. (운영체제, 시분할 시스템의 경우 다른 프로그램 실행 시간도 포함 될 수 있음.)
이 때 순수하게, 입출력이나 다른 프로그램의 실행 시간이 포함되지 않는 것을 `CPU 실행 시간` 이라고 한다.

컴퓨터의 성능이 좋다는 것은 `CPU 실행 시간`이 짧다는 의미이기 때문에 성능을 높인다, 향상한다라는 말은 CPU 실행 시간을 줄인다는 의미이다.


그래서 다음과 같은 식이 성립된다.
```
             1
성능 =   ----------- 
        CPU 실행 시간
```

성능 비율은 다음과 같은 식으로 나타낼 수 있다.
```
                                     B의 성능
컴퓨터 A 에 대한 B 의 성능 비율 = n = ----------
                                     A의 성능
``` 

성능은 실행 시간에 반비례하므로 다음과 같이도 정리할 수 있다.
```
                                   A의 실행 시간
컴퓨터 A에 대한 B의 성능 비율 = n =  ------------
                                   B의 실행 시간
```

### 암달의 법칙
암달의 법칙 : 시스템의 일부분을 개선하는 경우 전체 시스템에서 얻을 수 있는 최대 성능 향상을 구할 때 사용한다. 또한, 주로 병렬화에 의한 시스템 성능 향상의 한계를 지적하는데 사용된다.

다음의 예를 보자.
```
 - 하나의 프로그램이 싱글코어 프로세서를 사용하면 20시간 소요.
 - 해당 프로그램에서 1시간 소요되는 부분은 병렬화 할 수 없음. 나머지 19시간은 병렬화 가능
 - 병렬화된 부분을 처리하는데 사용되는 프로세서의 수 제한 없음.

무한대의 프로세서를 사용하면 병렬로 처리할 수 있는 시간은 0으로 줄일 수 있음. 하지만 병렬화하지 못하는 곳은 1시간이 무조건 걸림. 즉, 병렬화에 의한 최대 성능 향상은 20배가 됨.

그렇다면 식으로 통해 알아보자.

시스템의 일부분 f 는 병렬화 혹은 하드웨어의 개선으로 성능을 n배 향상하고 나머지 부분(1 - f)는 그대로 두었다고 가정.
성능 향상 전의 기계를 M1, 성능을 일부 향상한 기계 M2 라고 하고 전체 성능 향상 s

     M2 의 성능
s = -------------
     M1 의 성능

M1 의 실행 시간 = m 이라고 할 시,

                         영향을 받는 부분                                   f
M2 의 실행 시간 = m x {  ----------------- + 영향을 받지 않는 부분 }  =  m { -- + (1 - f) }
                          성능 향상 크기                                    n

따라서 M1 에 비해 M2의 시스템 전체 속도 향상 s 는 다음과 같다.
     
     M2 의 성능        M1 의 실행 시간            m                     1
s = ------------  =  ----------------- = ------------------  =  ---------------
                                               f                  f
     M1 의 성능        M2 의 실행 시간     m { -- + (1 - f)}       -- + (1 - f)
                                               n                  n

여기서 개선될 수 있는 부분에 대해 무한정으로 병렬화 하거나 하드웨어를 무한정으로 투자한다면 시스템의 전체 속도 향상은 다음과 같다.

          1          1
s = -------------- < -------
      f
     -- + (1 - f)     1 - f
      n

이는 아무리 개선하더라도 개선되지 않는 부분의 역수인  `1 / 1 - f` 보다 전체 시스템의 성능은 더 큰 속도 향상을 이룰 수 없다는 의미이다.
```

---

## CPU 성능 분석
컴퓨터는 일정한 주기를 가진 `클록 사이크(clock cycle)` 이 존재한다. 하나의 프로그램은 다수의 명령어를 포함하며, 컴퓨터는 명령어를 실행하기 위해 클록 사이클을 사용하기 때문이다.

### 성능에 영향을 미치는 요소
클록 속도 `1.0GHz` 는 `1초당 1.0 x 10의 9승` 사이클을 말하며, 클록 사이클은 `10의 -9 승 sec`, 즉 `1ns` 이다. 그렇다고 클록 속도가 높다고 해서 꼭 더 성능이 좋다는 것은 아니다. 그 예로 세발 자전거와 두발 자전거를 들 수 있다. 

CPU 성능은 프로그램 실행 시간으로 나타낼 수 있다. 하나의 프로그램에 대한 CPU 실행 시간, 즉 프로그램 실행 시간은 다음과 같이 3개의 요소로 나타낼 수 있다.
```
 CPU 실행 시간       명령어 개수       사이클 개수        시간
--------------  =  ------------  =  -------------  =  -------
   프로그램           프로그램           명령어          사이클
```

첫 번째 요소는 `하나의 프로그램에 포함된 명령어 개수` (프로그램의 크기) 를 의미한다. 
두 번째 요소는 `하나의 명령어를 실행하는데 필요한 클록 사이클의 수`를 의미한다. 이를 `CPI (cycles per instruction)` 이라고 한다. 보통 평균 CPI 를 사용함
세 번째 요소는 한 클록 사이클에 소요되는 시간 (클록 사이클 시간)을 의미한다 (사이클). 사이클 시간의 역수를 클록률 또는 크록속도 라고 한다.

그렇다면 CPU 실행 시간을 다시 정리하면 다음과 같다.

```
                                                               명령어 개수 X 평균 CPI
프로그램의 CPU 실행 시간 = 명령어 개수 X 평균 CPI X 사이클 시간 = -----------------------
                                                                      클록속도
```

명령어 개수는 아키텍처나 알고리즘에 결정이 된다.

평균 CPI 를 구하는 법은 다음의 예제를 참고하자.

명령어 종류 | 사용 빈도 | 사이클
---------- | -------- | ------
산술, 논리연산 명령어 | 50% | 1
적재, 저장연산 명령어 | 30% | 2
분기연산 명령어 | 20% | 3

그렇다면 평균 CPI 는 다음과 같다.

```
평균 CPI = 0.5 X 1 + 0.3 X 2 + 0.2 X 3 = 1.7 (사이클 / 명령어)
```

그렇다면 이제 두 컴퓨터에서 동일한 개수의 동일한 명령어를 포함하는 특정 프로그램을 수행할 때 어느 컴퓨터가 더 빨리 실행하는가에 대해서 알아보자.

컴퓨터 M1(3GHz) 과 M2(4GHz) 가 있고 각각 세 가지 유형의 명령어 그룹이 있다.

M1 의 명렁어 유형별 사용 빈도와 CPI : 

명령어 종류 | 사용 빈도 | 사이클
---------- | -------- | ------
산술, 논리 | 50% | 1
적재, 저장 | 30% | 2
분기 | 20% | 3

M2 의 명렁어 유형별 사용 빈도와 CPI : 

명령어 종류 | 사용 빈도 | 사이클
---------- | -------- | ------
산술, 논리 | 40% | 1
적재, 저장 | 30% | 1
분기 | 30% | 4

이제 성능을 비교하기 위해 실행 시간을 구할 것이다. 이 때 `프로그램의 크기`, `평균 CPI`, `클록 속도`가 필요하다. 각각의 컴퓨터에서 수행할 프로그램의 포함된 명령어 개수를 n 이라고 하자.

```
M1 의 평균 CPI : 0.5 X 1 + 0.3 X 2 + 0.2 X 3 = 1.7

M2 의 평균 CPI : 0.4 X 1 + 0.3 X 1 + 0.3 X 4 = 1.9
```

그렇다면 각 컴퓨터의 실행 시간은 다음과 같다.

```
                    n X 1.7
M1 의 실행 시간 = -------------
                  3 X 10의 9승
              
                    n X 1.9
M2 의 실행 시간 = -------------
                  4 X 10의 9승
```

따라서 컴퓨터 M1 에 대한 M2 의 성능 향상은 다음과 같다.

```
     M1 의 실행 시간       n X 1.7 X 4        6.8
s = ----------------  =  --------------  =  ----- = 1.19
     M2 의 실행 시간       n X 1.9 x 3        5.7
```

따라서 컴퓨터 M1 보다 컴퓨터 M2 가 약 1.19 배 빠르다.

### 성능에 영향을 미치는 요소 분석
시스템의 성능은 하나의 프로그램에 포함된 `명령어 개수`, `평균 CPI`, `프로세서 클록 사이클 시간` 의 영향을 받는다. 하지만, 각 요소가 독립적으로 성능을 결정 할 수 없음을 유의해야 한다.

#### 명령어 개수
실행된 명령어 개수는 알고리즘과 아키텍처에 의해 결정된다. 하나의 프로그램을 구성하는 명령어 개수는 간결한 알고리즘을 사용하면 줄어들고, 또한 하나의 명령어가 수행하는 일이 많으면 프로그램의 크기를 줄일 수 있음.

그래서 명령어 개수를 줄이려면 좋은 알고리즘을 사용하거나 강력하고 복잡한 명령어를 가진 `CISC(complex instruction set computer)` 아키텍처 구조를 사용한다.

#### 평균 CPI
평균 CPI 는 아키텍처와 컴퓨터 구현에 의해 결정된다. 복잡하고 강력한 명령어는 단순한 명령어보다 더 많은 사이클을 필요로 한다. 

따라서 평균 CPI 는 단순한 명령어로 구성된 `RISC(reduced instruction set computer)` 아키텍처를 사용하면 낮출 수 있다.

#### 클록 사이클 시간
사이클 시간은 주로 컴퓨터 구현과 실현 수준에 의해 결정된다.

컴퓨터 구현 수준에서는 `데이터 경로`가 짧으면 일반적으로 지연 시간이 짧아져 사이클 시간도 짧아진다. 또한 파이프라이닝 기술을 사용하면 한 사이클 동안에 수행할 작업의 양이 작아지므로 클록 속도가 빨라진다.

이제 반대로 아키텍처, 컴퓨터 구현, 컴퓨터 실현이 컴퓨터의 성능을 결정하는 요소인 명령어 개수, 평균 CPI, 클록 사이클 시간에 어떤 영향을 미치는지를 살펴보자.

- 아키텍처 수준 : CISC 를 사용하면 프로그램 크기가 줄어듦. 하지만 명령어가 복잡하고 강력하기 때문에 평균 CPI 와 사이클 시간이 커짐. RISC 를 사용하면 명령어 개수는 늘어나지만 명령어가 단순해 평균 CPI 와 사이클 시간이 줄어듦.

- 컴퓨터 구현 수준 : 시스템을 병렬화하면 평균 CPI 가 줄어듦. 하지만 병렬화에 따른 부담으로 사이클 시간이 늘어날 수 있음.

- 컴퓨터 실현 수준 : 더 빠른 회로 기술을 사용하거나 패키징 밀도를 높이면 사이클 시간이 줄어듦. 하지만 비용이 높아짐.

따라서 시스템의 성능 향상하기 위해 아키텍처, 컴퓨터 구현, 컴퓨터 실현 사이의 적절한 절충이 필요함.

---

## 벤치마크와 성능 척도
성능 평가에 일반적으로 자주 이용되는 프로그램을 쓰는데, 이 때 작업 부하로 선택된 프로그램의 집합을 `벤치마크`라고 한다.

### 밴치마크
워크스테이션이나 서버등의 성능을 평가하는데 널리 사용되는 `SPEC(Standard Performance Evaluation Corporation)`에서 개발한 SPEC 벤치마크 모음이 있다.

벤치마크 프로그램을 사용하면 시스템의 각종 성능을 평가할 수 있다. 쉽게 사용할 수 있는 척도로 `CPI`, `클록속도`, `MIPS`, `MFLOPS` 가 있다. 그 외로 CPU 와 메모리 시스템의 성능을 종합적으로 평가할 수 있는 `SPECratio`, 기호 조작 및 논리 추론 능력에 중점을 둔 `KLIPS` 등이 있다.

하지만 어떤 성능 척도도 컴퓨터 시스템의 공급자에 의해 왜곡되어 사용될 수 있음을 유의하자.ㄴ

### MIPS 와 MFLOPS
- IPS(instructions per second) : 컴퓨터의 프로세서 속도를 가늠하기 위한 척도. 1초 동안 실행한 명령어 개수를 의미.

- MIPS(million instructions per second) : 1초에 수행한 명령어 개수를 100만으로 나눈 값.

- MFLOPS(million floating point opertaions per second) : 실행한 명령어 개수 대신 부동 소수점 연산의 수를 이용하는 것. 

그렇다고 MIPS, MFLOPS 값이 높다고 해서 성능이 더 좋다고 할 수 없다.

