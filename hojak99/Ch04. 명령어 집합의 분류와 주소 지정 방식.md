# 명령어 집합의 분류와 주소 지정 방식

## 피연산자의 수와 명령어 집합

- 명렁어 : 어떤 연산을 수행할 것인가를 나타내는 `연산 부호` 와 연산될 데이터에 대한 정보를 포함하는 `피연산자`로 구성됨.
     - 연산 부호 : 특별한 경우 아니면 하나의 필드에 존재
     - 피연산자 : 여러 개의 필드로 구성 가능. 
         - 0-주소 명령어(스택 컴퓨터), 1-주소 명령어(누산기 컴퓨터), 2-주소 명령어 및 3-주소 명령어(범용 레지스터 컴퓨터)

### 누산기 컴퓨터
- 메모리-메모리 컴퓨터 : CPU 내부에 데이터 저장하는 기억장치 없음
    - 누산기 컴퓨터 : 해당 컴퓨터에 하나의 데이터를 저장하기 우히나 레지스터를 추가한 컴퓨터.
        - 누산기를 묵시적 피연산자로 사용. (유일하게 데이터를 저장할 수 있기에 굳이 명시할 이유 없기 때문)
        - 적재 혹은 저장 명령어가 아니면 누산기는 `근원지 겸 목적지 레지스터`로 사용
        - 메모리를 명시적 피연산자로 사용.
        - 기억장치가 하나의 워드 용량인 누산기만 있어 단순, 저렴함.

누산기 컴퓨터는 하나의 레지스터만 사용할 뿐인데 메모리 트래픽의 감소 효과 큼
  - 전화기의 재발신 버튼을 예로 들 수 있음. (버튼 누르는 횟수 줄기 때문)


### 스택 컴퓨터
- 스택 컴퓨터 : CPU 내부에 다수의 데이터를 임시로 저장하기 위해 스택을 사용하는 컴퓨터
    - 스택에 저장된 모든 데이터는 위치에 따라 접근 시간 다름.
    - 대부분의 연산은스택의 최상위 또는 차상위 데이터를 사용.
    - 최근 연산한 데이터는 스택의 최상위에 저장
    - 보관할 데이터의 양이 스택 용량보다 크면 스택의 최하위에 있는 데이터부터 삭제해야 하므로 성능이 많이 떨어짐.

스택 컴퓨터는 메모리에 접근하기 위해 다음과 같은 명령어를 사용함.
- push : 메모리에서 스택의 최상위로 데이터를 이동하는 명령어
- pop : 스택의 최상위에 있는 데이터를 메모리로 이동하는 명령어

push 와 pop 외의 명령어는 지정된 장소인 스택의 최상위 데이터 1~2개를 사용해 연산하여 피연산자를 명시할 필요가 없음. 그래서 0-주소 명령어 컴퓨터라고도 하는 것.

스택 컴퓨터는 누산기 컴퓨터보다 폰노이만 병목에 대한 부담을 줄여준다. (책의 표를 참고)]
하지만 스택의 특성 때문에 애플리케이션에 따라 누산기 컴퓨터보다 스택 컴퓨터의 성능이 나쁠 수 있음.

### 범용 레지스터 컴퓨터
- 범용 레지스터 컴퓨터 : CPU 내부에 다수의 데이터를 임시로 저장하기 위해 범용 레지스터를 사용하는 컴퓨터.
     - 스택과 달리 모든 레지스터의 접근 시간이 동일, 순서 상관없이 임의로 접근 가능
     - 누산기, 스택과 달리 레지스터가 피연산자로 사용. 데이터가 다수의 레지스터 중 하나에 저장되기에 레지스터 주소를 명시해야 함.

범용 레지스터는 피연산자의 수에 따라 2-주소 명령어 컴퓨터나 3-주소 명령어 컴퓨터가 될 수도 있음.

```
add r1, r2        ; r1 <- r1 + r2 (2-주소 명령어)
add r1, r2, r3    ; r1 <- r2 + r3 (3-주소 명령어) 
```

2-주소 명령어를 수행하면 근원지 겸 목적지로 사용하는 레지스터의 내용이 수정되기 때문에 근원지 내용 1개를 더 이상 사용할 수 없음. 즉 add 명령어를 수행하기 전의 r1 값이 연산결과에 의해 파기.
그러나 피연산자가 2개만 필요해 명령어의 길이가 짧아지는 이점이 있음.

3-주소 명령어는 2-주소 명령어에 비해 크기가 길어지나 연산을 수행한 후에도 근원지 레지스터의 내용이 변하지 않음.

---

- 적재-저장 명령어 컴퓨터 : 범용 레지스터 컴퓨터가 다음 명령어만 메모리에 접근할 수 있도록 제한한 것.
    - 적재 명령어 : 데이터를 메모리에서 CPU 레지스터로 전송
    - 저장 명령어 : 데이터를 CPU 레지스터에서 메모리로 전송

적재-저장 명령어 컴퓨터는 add, mul 명령어의 피연산자로 메모리 주소 사용할 수 없음을 유의.

레지스터 주소가 메모리 주소보다 짧아 범용 레지스터 컴퓨터의 명령어 길이는 메모리-메모리 컴퓨터의 명령어 길이보다 짧음. 따라서 명령어를 위한 메모리 트래픽 줄어듦. 
또한, 사용 빈도가 높은 데이터를 레지스터에 두기 때문에 데이터를 위한 메모리 트래픽이 줄어듦.

---

## 명령어와 메모리
명령어는 수행해야 할 연산에 대한 데이터 또는 데이터에 대한 정보를 명시해야 함. 해당 절에서 메모리의 속성, 메모리 내부의 데이터 정렬, 메모리에 데이터를 저장하는 순서인 엔디언 방식에 대해 살펴본다.

### 메모리 속성
명령어와 데이터는 컴퓨터의 메모리에 적재되어야 CPU 가 사용할 수 있음. 메모리에 알아보기 전 해당 용어를 숙지하자.

#### 워드
- 워드 : 명령어와 데이터를 포함할 수 있는 메모리 구성 요소 중 하나. 고정된 개수의 비트라는 메모리 소자로 이루어짐. 

#### 주소
메모리는 주소라는 고유의 번호를 사용하여 명령어나 데이터를 참조. 
쉽게 비유하자면 메모리는 그릇의 집합, 그릇 속의 내용물은 데이터, 그릇에 표시된 번호는 주소라고 할 수 있다.

데이터를 큰 단위로 다루면 주소가 짧아지지만 작은 단위의 데이터를 취급하기 어렵다. 적절히 조정하자.

#### 주소 지정 단위
주소 지정 단위 : 그릇의 크기에 해당하며 주소 해상도를 결정함.

여기서 주소 해상도는 아키텍처가 직접 명시할 수 있는 정보의 최소 단위를 명시한다. 보통 비트 단위의 주소 해상도를 사용하지 않는데 이는 비트 단위까지 주소를 분해하면 주소를 나타내는데 많은 비트가 필요, 데이터 정렬에 추가 시간이 필요하기 때문.

오늘 날의 아키텍처는 대부분 8비트, 16비트, 또는 그 배수 단위의 주소 해상도를 사용한다.
8비트나 16비트 단위의 주소 해상도는 비트 단위의 주소 해상도에 비해 주소의 길이를 3비트나 4비트 줄일 수 있고 정렬 시간도 줄일 수 있다.

일반적으로 메모리의 주소 지정 단위는 8비트로 구성된 바이트를 사용하는데 이를 바이트 주소라고 한다.

그리고 대부분의 아키텍처는 일관성과 간결성을 위해 명령어와 데이터에 대해 동일한 주소 해상도를 사용한다. 

### 메모리 정렬
정렬된 메모리 : 주소 해상도가 바이트라 할지라도 명령어와 데이터를 강제로 정렬하는 방식을 말함.

즉, 2바이트로 구성된 명령어와 데이터는 2의 배수로 시작되는 주소를 갖도록 강제하는 방식이다. 이는 컴퓨터를 구현할 때 실행 속도를 높이기 위한 요구 사항이다.
그러나 하프워드나 워드 데이터가 2의 배수나 4의 배수가 아닌 주소에 위치할 경우 데이터가 정렬되지 않았다고 한다.

특히, 정렬되지 않은 워드 데이터를 적재하려면 2개의 메모리 읽기 사이클을 실행해야 한다. 반대로 워드 데이터가 정렬되어 있다면 1개의 메모리 읽기 사이클만 수행하면 된다.
그래서 대부분 명령어나 데이터를 정렬함으로써 성능을 높인다.


### 엔디언 방식
- 엔디언 : 여러 개의 연속된 대상을 1차원 공간에 배열하는 방법

예를 들어, 32비트 컴퓨터의 경우 메모리 워드에 32개의 비트를 배열하거나 개의 바이트를 배열하는 방법이다.

일반적으로 엔디언은 바이트를 배열하는 후자를 의미하는데, 비트와 바이트, 워드의 순서는 어느 방법이든 성능에 차이가 없다고 알려져 있다. 그러나 컴파일된 실행 파일을 다른 아키텍처로 이삭할 때는 워드 내부의 비트 혹은 바이트의 순서가 달라지기 때문에 의미가 있다.

바이트를 메모리 워드 내부에서 배열하는 방식 다양하지만 주로 `빅 엔디언`, `리틀 엔디언` 방식을 사용한다.

- 빅 엔디언 방식 : 왼쪽에서 오른쪽으로 바이트를 배열한 것.
     - 각 워드 최대 유효 비트가 포함된 바이트의 주소가 워드 주소가 된다.
- 리틀 엔디언 방식 : 오른쪽에서 왼쪽으로 바이트를 배열한 것
     - 작은 다위의 바이트가 앞자리에 위치하여 각 워드의 최소 유효 비트가 포함된 바이트의 주소가 워드 주소가 된다.

## 주소 지정 방식
주소 지정 방식은 명령어의 일부인 피연산자 필드를 사용하여 데이터가 실제 위치한 유효 주소를 결정하는 방법이다.

주소 지정 방식의 종류는 매우 다양하다. 이는 피연산자 정보를 가지고 몇 단계를 거쳐 원하는 데이터에 접근할 수 있느냐에 따라 단계별로 분류할 수 있다. 일반적으로 주소 확정을 위한 단계가 깊을 수록 데이터를 참조하는데 시간이 오래 걸리나 더 많은 데이터를 다양한 방법으로 보관할 수 있다는 장점도 있다.

명령어의 피연산자 필드와 데이터 실제 위치의 관계를 나타내기 위해 다음과 같은 표기를 사용한다.

- r : 명령어 내의 피연산자 필드가 명시하는 레지스터 주소
- a : 명령어 내의 피연산자 필드가 명시하는 메모리 주소
- ea : 참조되는 데이터를 포함하는 장소의 실제 주소, 즉 유효 주소
- Reg[x] : 레지스터 x 의 내용
- M[x] : 메모리 x 번지의 내용

### 0-단계 주조 지정 방식
데이터가 있는 위치를 파악하기 위해 특별한 과정이 필요없는 방식으로, 데이터의 유효 주소를 명시하지 않는다.

0-단계 주소 지정 방식은 크게 `즉치 주소 지정 방식`, `묵시 주소 지정 방식` 으로 구분된다.

#### 즉치 주소 지정
즉시 주소 지정, 즉석 주소 지정, 상수 주소 지정 등으로도 불린다. 

해당 방식은 명령어의 피연산자 필드에 데이터가 포함되어 있어 주소 지정과는 상관이 없다. 따라서 명령어를 CPU 로 인출만 하면 데이터가 바로 보이기 때문에 즉시 이용할 수 있다.
그러나 명령어의 일부를 사용하므로 제한된 비트로 표현될 수 있는 0, 1 같은 작은 정수 데이터를 위한 공간으로 유용하다. 또한, 상수와 같이 변경하지 않는 데이터를 위해 사용한다.

#### 묵시 주소 지정
누산기나 프로그램 계수기 등과 같은 정해진 기억장치에 데이터가 저장된다. 

항상 정해진 장소에 데이터가 있기 때문에 위치를 명시할 필요가 없다. 
그러나 유효 주소를 계산할 필요는 없지만 데이터를 사용하려면 하나의 기억장치를 읽어야 하며, 제한된 기억 장치에 국한되기 때문에 많은 데이터에 대해 사용할 수 없다.

### 1-단계 주소 지정 방식
데이터의 위치, 즉 유효 주소를 확정하기 위해 주소 계산이나 읽기 연산 과정을 한 번 수행하는 방식이다.

해당 주소 지정 방식부터 데이터의 위치를 확정하기 위해 명령어의 피연산자 필드를 주소로 사용한다.

#### 레지스터 직접 주소 지정
레지스터 주소 지정이라고도 하며, 데이터가 레지스터 파일 중의 한 곳에 있고 데이터가 있는 레지스터의 주소를 명령어의 피연산자 필드에 명시하는 방식이다.

해당 방식은 높은 효율과 빠른 속도로 대부분의 아키텍처에서 사용된다.
레지스터 파일이 온칩으로 구현되어 메모리나 캐시보다 매우 빠르지만 용량이 작아, 자주 사용하는 소수의 데이터를 레지스터에 저장하여 빨리 접근하고자 할 때 사용한다. 

레지스터 직접 주소 지정 방식은 레지스터 주소가 짧아, 짧은 피연산자 필드를 요구할 뿐만 아니라 데이터 접근 속도도 빠르다. 그러나 레지스터 개수를 초과하는 데이터 집단을 취급할 때 효율적으로 사용하기 어렵다.

이 방식의 데이터 주소 확정 과정은 다음과 같이 나타낼 수 있다.

```
ea = r
```

#### 직접 주소 지정
데이터가 있는 메모리의 주소를 명령어 피연산자 필드에 명시하는 방식이다. 

데이터를 참조하려면 피연산자 필드에 명시된 메모리 주소를 사용하여 메모리에 접근하면 된다. 하지만 메모리 주소 공간 전체를 사용하려면 메모리의 절대 주소 길이만큼 긴 피연산자 필드가 필요하므로 명령어가 너무 길어진다. 따라서 명령어의 길이를 줄이려면 모리 주소 공간의 일부만 사용하거나 메모리 용량을 줄여야 한다.

이 방식의 데이터 주소 확정 과정은 다음과 같이 나타낼 수 있다.
```
ea = a
```


### 2-단계 주소 지정 방식
데이터의 유효 주소를 확정하기 위해 주소 계산이나 읽기 연산 과정을 두 번 수행한다.

해당 방식은 데이터가 메모리에 저장되므로 많은 데이터의 위치를 명시할 수 있다.
그러나 주소를 확정하기 위해 2-단계 과정을 거쳐야 하므로 0-단계 혹은 1-단계 주소 지정 방식보다 데이터를 참조하는데 더 많은 시간이 걸린다. 

#### 레지스터 간접 주소 지정
피연산자 필드가 레지스터 주소를 명시하며, 레지스터의 내용이 데이터를 위한 메모리의 주소를 명시한다. 따라서 피연산자 필드에 명시된 레지스터를 읽은 다음, 레지스터의 내용이 가리키는 주소를 사용하여 메모리에 접근함으로써 데이터를 참조할 수 있다.

이 방식의 데이터 주소 확정 과정은 다음과 같이 나타낼 수 있다.

```
ea = Reg[r]
```

#### 메모리 간접 주소 지정
데이터가 있는 메모리의 주소를 간접적으로 명령어의 피연산자 필드에 명시하는 방식으로, 간략하게 간접 주소 지정이라고도 한다.

이 방식은 직접 주소 지정의 단점인 메모리 주소 공간이나 메모리 용량의 제약을 해결해주지만 데이터를 참조하기 위해 두 번에 걸친 메모리 접근이 필요하다.
데이터 주소 확정 과정은 다음과 같이 나타낼 수 있다.

```
ea = M[a]
```

#### 변위 주소 지정
명령어에 포함된 2개의 피연산자 필드를 사용하여 데이터가 있는 메모리 주소를 확정하는 방식으로, 색인 주소 지정과 베이스 주소 지정이 있다.

이 방식의 데이터 주소 확정 과정은 다음과 같이 나타낼 수 있다.

```
ea = Reg[r] + a
```