# 명령어 집합

## 명령어 집합의 의미

오늘날 대부분의 프로그램은 높은 생산성, 오류 탐지 및 유지보수 용이함 등과 같은 장점을 지닌 고급언어로 작성되지만, 궁극적으로 프로그램은 **컴파일러나 인터프리터 **등을 통해 **기계 명령어(기계어)로 변환**되어야만 컴퓨터 하드웨어나 마이크로프로그램에서 인식되거나 실행될 수 있다.

명령어는 **CPU가 수행할 동작을 2진수 코드로 정의한 것**으로, 일반적으로 2진수 코드 대신에 연상 부호(곱하기 Multiply = MUL)를 사용한 어셈블리 형태의 명령어로 표현한다.

## 명령어 집합 구조

명령어 집합 구조(ISA: instruction set architecture)는 작성된 프로그램과 그 프로그램을 수행할 컴퓨터 하드웨어 사이의 **인터페이스에 대한 완전한 정의 혹은 명세**를 뜻한다.

ISA는 컴퓨터 하드웨어가 수행할 수 있는 모든 명령어에 대해 다음과 같은 내용을 명시한다.

- 컴퓨터 하드웨어가 어떤 연산을 수행할 수 있고, 각 연산에 어떤 데이터가 필요한지를 명시한다.
- 사용할 수 있는 데이터의 표현방식, 즉 데이터 형식을 명시한다.
- 데이터의 위치에 대한 정보를 알려주는 주소 지정 방식을 명시한다.

ISA에 명시된 연산, 데이터 형식, 주소 지정 방식의 수는 컴퓨터 종류마다 다르다.

## 명령어 집합 설계

명령어 집합을 설계하려면 컴퓨터와 관련하여 복잡하고 서로 영향을 미치는 많은 사항을 고려해야 하고, 다양한 설계 논점이 발생한다.

##### 연산의 종류

연산의 종류는 **명령어가 프로세서에서 수행할 수 있는 일의 종류**를 의미한다. 일반적으로 연산에는 **전송(transfer), 처리(processing), 제어(control), 입출력 (I/O) 연산**의 네가지 종류가 있다. 컴퓨터에서 사용하는 아키텍처마다 이러한 네 종류의 연산이 필요하지만 모두 동일하지는 않다.

##### 데이터 형식

데이터 형식은 **데이터에 가능한 값, 데이터에 실행할 수 있는 명령, 데이터의 의미, 데이터 값을 저장하는 방식**을 의미한다. 이는 데이터의 속성 중 하나로 컴퓨터와 프로그램이 취급할 수 있는 데이터의 종류를 명시하고 데이터를 식별하는 분류이다. 일반적으로 아키텍처는 **정수, 실수, 문자** 등과 같은 데이터 형식을 지원하며, 일부 아키텍처는 문자열과 같은 데이터 형식도 지원한다.

##### 명령어 형식

명령어 형식은 **명령어 구성 부분을 나타내는 양식**을 의미한다. 명령어는 최소한 연산의 종류를 지정하는 연산 부호(operation code)를 포함한다. 연산의 종류에 따라 명령어는 소수의 피연산자를 가질 수 있으며, 피연산자는 데이터의 주소나 데이터 자체가 될 수 있다.

#####피연산자의 주소 지정 방식

연산의 종류에 따라 데이터가 필요할 수 있고, 데이터는 다양한 위치에 존재하는데, 명령어 내부에 존재할 수도 있고 레지스터나 메모리에 존재할 수도 있다. 피연산자인 **데이터의 위치를 명시하기 위해 명령어는 주소 지정 방식**을 가지고 있다.



# 명령어의 특성

일반적으로 명령어는 다음과 같은 여러 가지 요소로 구성된다.

- 연산 부호 : 컴퓨터가 수행할 덧셈, 뺄셈 등과 같은 연산의 종류를 명시한다.
- 피연산자 필드 : 연산될 데이터를 위한 정보를 포함한다. 
- 모드 비트 : 피연산자의 위치에 대한 명시 방법을 나타낸다.
- 다음 명령어 주소 필드 : 다음 명령어의 위치를 나타낸다. 명령어는 순차적으로 실행된다고 가정하므로 다음 명령어가 다음 주소에 위치하기에 일반적으로는 필요하지 않다.

## 피연산자의 수

초기의 컴퓨터는 데이터의 산술연산이 주된 목적이었으므로 명령어의 기본적인 형식은 산술연산을 기반으로 형성된 것이라고 볼 수 있다. 따라서 산술연산에 대한 다음과 같은 수학적 표현을 살펴보면 명령어의 형식을 쉽게 이해할 수 있다.

![산술연산의 수학적 표현](https://latex.codecogs.com/gif.latex?z&space;=&space;f(x,&space;y))

위 식을 명령어와 비교하면 f는 연산 부호이고 x, y, z는 피연산자에 해당한다. 컴퓨터의 경우 x, y, z를 명령어의 피연산자 필드로 명시하는데, 이 필드는 메모리 주소나 레지스터 주소와 같은 데이터 위치를 포함할 수도 있고 값 자체를 포함할 수도 있다. 이러한 필드를 일반적으로 **주소 필드**라고 한다.

다음은 피연산자의 수에 따른 명령어의 예이다.

| 피연산자의 수        | 예                  | 의미               |
| -------------------- | ------------------- | ------------------ |
| 피연산자가 없는 경우 | halt                | 프로그램 정지      |
| 단항 피연산자        | nor r1              | r1 <- not(r1)      |
| 이항 피연산자        | add r1, r2          | r1 <- r1 + r2      |
| 삼항 피연산자        | add r1, r2, r3      | r1 <- r2 + r3      |
| 다항 피연산자        | madd r1, r2, r3, r4 | r1 <- r2 + r3 + r4 |

앞서 예로 든 식과 같이 대부분의 명령어는 3개의 데이터 주소를 갖는데, 이를 3-주소 명령어 (3-address instruction)라고 한다. 유의할 점은 명령어의 종류에 따라 피연산자의 수가 다를 수 있다.

피연산자의 수와 피연산자를 위한 비트 수가 많으면 명령어가 길어져 프로그램이 많은 메모리를 차지한다. 특히 메모리 가격이 고가였을 때 명령어의 길이를 줄여야 했는데, 컴퓨터 설계자는 다음과 같은 방법으로 명령의 길이를 줄이고자 하였다.

- 메모리 주소 대신 레지스터 주소로 피연산자 명시

  메모리의 용량은 레지스터의 용량보다 매우 크다. 그렇기 때문에 메모리 주소는 아주 많은 비트를 필요로 하지만 레지스터 주소에 필요한 비트는 매우 적다. 하지만 레지스터의 수가 적기 때문에 소수의 데이터만 사용할 수 있다.

- 근원지 피연산자 중 하나를 목적지 피연산자와 겸용

  3개의 피연산자 필드 중에서 1개를 줄이기 위해 다음과 같은 연산을 사용한다.

  ![목적지 피연산자와 겸용](https://latex.codecogs.com/gif.latex?z=f(x,&space;z))

  변수 z를 근원지 겸 목적지 피연산자로 함수 f()는 변수 x와 z만 사용한다. 이와 같은 연산을 수행하는 명령어를 **2-주소 명령어**라고 한다. 연산 결과를 근원지 피연산자 중 하나에 저장하는 방식이다. 따라서 피연산자 필드가 3개에서 2개로 줄어들기 때문에 **명령어의 길이가 짧아지지만 근원지 피연산자 중의 하나가 파괴된다.**

- 묵시적 피연산자 사용

  데이터가 항상 동일한 위치에 있는 것 같이 주소를 명시할 필요가 없는 피연산자를 묵시적 피연산자 (implicit operand)라고 하며, 이를 함수에 적용하면 다음과 같다.

  ![묵시적 피연산자 사용](https://latex.codecogs.com/gif.latex?Acc&space;=&space;f(Acc,&space;x))

  Acc는 누산기 (Accumulator)를 의미하며 묵시적 피연산자에 해당한다. 함수 f()를 수행할 때 누산기를 항상 근원지 겸 목적지 피연산자로 사용한다. 그렇기 때문에 피연산자인 x만 명시하면 된다. 이와 같은 명령어를 1-주소 명령어라고 한다.

- 스택 사용

  스택을 사용하면 데이터의 위치를 명시할 필요가 없다. 예를 들어, 피연산자가 2개이면 스택의 최상위에 있는 2개의 데이터를 사용하면 된다. 스택을 사용할 때는 필요한 데이터를 스택의 최상위에서 하나씩 사용하면 되므로 피연산자를 명시할 필요가 없다. 이와같이 **명시적 피연산자가 필요 없는 명령어를 0-주소 명령어**라고 한다.

## 명령어의 길이

명령어는 길이의 특성에 따라 다음과 같이 두 가지로 분류한다.

- 고정 길이 명령어 형식

  명령어의 종류나 명령어에 포함된 구성 요소와 상관없이 명령어의 길이가 모두 일정한 명령어 형식을 말한다. 명령어 해독 과정을 위한 하드웨어를 단순하게 구현할 수 있으나, 짧은 길이만 필요한 간단한 명령어도 긴 명령어와 동일한 길이로 맞춰야하므로 프로그램의 크기가 증가할 수 있다.

- 가변 길이 명령어 형식

  명령어의 종류나 명령어에 포함된 구성 요소에 따라 다양한 길이의 명령어를 사용하는 명령어 형식을 말한다. 프로그램의 크기가 작아지고 강력한 명령어를 도입할 수 있으나 프로세서를 설계하기가 어렵다.



# CPU의 기본 구성과 가상 명령어 집합

## CPU의 기본 구성과 명령어의 실행 순서

폰노이만 컴퓨터는 CPU, 메모리, 입출력장치를 제공한다. CPU는 제어장치와 산술논리장치로 구성된다. 그리고 CPU는 명령어와 데이터 등을 위해 다음과 같은 레지스터를 사용한다.

- 프로그램 계수기 :  다음에 실행할 명령어의 주소를 보관하는 레지스터이다. 명령어를 인출한 후에는 명령어의 길이만큼 증가되어 다음 명령어를 가리켜야 한다.
- 명령어 레지스터 : 가장 최근에 인출한 명령어를 보관하는 레지스터이다.
- 누산기 : 데이터를 일시적으로 보관하는 레지스터이다.
- 메모리 주소 레지스터 :  프로세서가 메모리에 접근하기 위해 참조하려는 데이터의 주소를 명시하는 버퍼를 말한다.
- 메모리 버퍼 레지스터 : 프로세서가 메모리로부터 읽거나 메모리에 저장할 데이터 자체를 보관하기 위한 버퍼를 말한다. 

**CPU가 메모리에 있는 데이터를 읽어오는 것을 적재**라 하고, **메모리에 데이터를 기록하는 것을 저장**이라 한다.  적재 및 저장 명령어의 실행 과정은 일반적으로 다음과 같다.

- 적재 과정(메모리 -> CPU)
  1. 프로세서는 데이터가 있는 메모리의 주소를 MAR에 보낸다.
  2. MAR이 지정하는 메모리 주소에 있는 데이터를 읽어와 MBR에 저장한다.
  3. 프로세서는 MBR에 저장된 데이터를 읽는다.
- 저장과정(CPU -> 메모리)
  1. 프로세서는 데이터를 저장할 메모리의 주소를 MAR에 보낸다.
  2. 프로세서는 데이터를 MBR에 저장한다.
  3. 프로세서는 MBR에 저장된 데이터를 읽는다.

컴퓨터마다 명령어 실행 과정이 동일하지는 않지만 일반적으로 최소한 다음과 같은 과정을 거친다. 여기서 **명령어를 수행하는 일련의 과정을 명령어 사이클**이라고 한다.

1.  **실행할 명령어를 메모리에서 읽어 CPU로 가져오는 것을 인출 사이클**이라고 한다. 먼저 PC가 가리키는 메모리 주소를 MAR에 보내면, 메모리는 MAR이 지시하는 메모리의 내용인 명령어를 MBR에 보낸다. MBR에 있는 명령어를 IR에 저장하고, 다음 명령어를 가리키도록 PC의 내용을 갱신한다.  결과적으로 **명령어 인출 사이클 동안 PC가 가리키는 명령어를 IR에 저장하고, PC로 하여금 다음 명령어를 가리키도록 갱신**한다.
2. **인출한 명령어에 포함된 연산 부호가 의미하는 연산을 수행하는 것을 실행 사이클**이라고 한다. 예를 들면 덧셈 명령어는 먼저 피연산자가 가리키는 메모리의 데이터를 MBR로 가져온 다음, MBR의 내용과 Acc의 내용으로 덧셈 연산을 수행한 후 Acc에 저장한다. 인출한 연산 부호가 적재 혹은 저장 명령어라면 실행 사이클 동안 앞서 살펴본 적재 과정이나 저장 과정을 수행한다.

## 가상 컴퓨터 명령어

가정에 대한 설명이므로 책 참고.

## 좋은 명령어 집합 구조

**명령어 집합 구조는 하드웨어와 소프트웨어 사이에서 인터페이스 역할을 수행**하기 때문에 잘못 설계하면 복잡한 구성의 하드웨어가 필요하거나 소프트웨어 개발을 어렵게 만들 수 있다. 프로세서를 설계할 때 먼저 결정해야 할 일은 명령어 집합 구조를 정의하는 것이다. 명령어 집합 구조는 프로세서와 직접적으로 소통할 수 있는 언어로, 프로그래밍 방법론을 정의할 뿐만 아니라 프로세서 구현의 많은 부분도 결정한다.  우수한 명령어 집합 구조가 갖춰야 할 특성은 다음과 같다.

- 일관성 : 일부 명령어의 구조만 알더라도 나머지 명령어의 구조를 예측할 수 있어야 한다.
- 직교성 : 명령어 구성 요소 사이의 독립성을 유지하는 것으로, 명령어의 구성 요소가 연산 부호와 독립적으로 결정된다는 뜻이다.
- 적절성 : 모든 컴퓨터의 기능은 시스템의 필수 요구 조건에 포함되어야 한다. 본질적이지 않거나 기능과 관계없는 부분은 최소화해야 한다.
- 일반성 : 하나의 기능을 다양한 목적으로 사용할 수 있는 것을 의미한다.



# 연산

## 연산의 종류

컴퓨터는 크게 전송연산, 처리연산, 입출력 연산을 제공해야 한다. 각 연산은 다음과 같다.

- 전송 연산 : CPU 내의 레지스터와 메모리 사이에 데이터를 교환하는, 적재 및 저장하는 연산이다. **데이터를 메모리에서 프로세서로 이동하는 것을 적재 연산**이라 하고, **데이터를 프로세서에서 메모리로 이동하는 것을 저장 연산**이라 한다.  전송을 위한 연산에는 대부분 2개의 피연산자가 있으므로 근원지 피연산자와 목적지 피연산자의 위치가 명시되어야 한다.
- 처리 연산 : 산술논리장치를 사용하여 데이터를 조작하는 연산이다. 처리 연산은 크게 덧셈 및 뺄셈과 같은 **산술 연산**과 자리 이동과 회전 이동 같은 **논리 연산**, 10진수를 변경하는 등의 데이터의 형식을 변환하는 **변환 연산**으로 나뉜다.
- 제어 연산 : CPU의 제어장치가 프로그램의 실행 순서를 제어하는 연산이다. 아키텍처가 제어 기능을 수행하는 명령어를 지원함으로써 프로그래밍 언어에 융통성과 일반성을 제공하기 때문에 프로그램에서 명령어의 순서는 항상 순차적이지 않다.
- 입출력 연산 : CPU 내의 레지스터와 외부 장치 사이의 데이터 이동을 수행하는 연산으로, 입출력 연산도 데이터를 전송하므로 전송 연산에 포함하기도 한다.

## 분기 명령

프로그램에 포함된 명령어는 비순차적으로 수행될 수도 있는데, 다음에 수행되어야 할 명령어의 위치는 일반적으로 현재의 명령어에 의해 다음과 같은 방법으로 결정된다.

- 체인 방식 : **명령어가 다음 명령어의 위치를 명시하는 방식이다**. 체인 방식은 다음에 수행할 명령어의 위치를 현재 명령어를 통해 직접 알 수 있다. 명령어의 길이가 길어지므로 오늘날의 컴퓨터에서는 사용하지 않지만 마이크로프로그래밍에 사용되기도 한다.
- 분기 방식 : **명령어에 다음 명령어의 위치를 명시하지 않고, 실행될 다음 명령어는 기본적으로 현재 명령어의 다음 위치에 있다고 간주하는 방식이다**. 명령어의 실행 순서를 비순차적으로 변경하고자 할 때는 분기 명령어를 사용한다. 명령어의 길이가 짧고 다음 명령어를 예측할 수 있기 때문에 구현하기가 용이하다.

분기 명령은 조건에 따라 분기 여부를 결정하는 조건 분기 명령과 조건에 관계없이 분기하는 무조건 분기 명령으로 구분한다.

프로그램 흐름의 경로 결정은 이전에 생성된 결과를 기반으로 한다.

```pseudocode
if(x > y)
then goto BIGGER
else goto SMALLER
```

이와 같은 조건 분기 명령은 다음과 같은 과정을 필요로 한다.

- 비교 혹은 산술 및 논리와 같은 연산을 수행하여 검사할 조건을 생성
- 생성된 조건을 판단하여 다음 명령어의 위치를 선택하는 것이다.

첫번째 과정에서 검사할 조건은 다음과 같이 묵시적으로 생성될 수도 있고 명시적으로도 생성될 수도 있다.

- 묵시적으로 조건을 생성할 경우 : 산술연산 및 논리연산이 실행될 때마다 생성되는 부수 효과를 조건으로 사용한다.
- 명시적으로 조건을 생성할 경우 : CMP, TST와 같은 특별한 명령어를 사용하여 비교하거나 테스트를 수행한 결과를 검사할 조건으로 사용한다.

어떤 방법으로 비교하더라도 생성된 조건을 사용하려면 저장해둬야 한다. 오늘날의 컴퓨터는 대부분 **플래그 레지스터를 사용하여 명령어 실행 중에 생성된 조건을 저장**하지만, 일부 컴퓨터는 범용 레지스터에 저장하는 경우도 있다. 

대부분의 아키텍처는 생성된 조건에 기초하여 명령어의 실행 순서를 변경할 수 있도록 조건 분기 명령어를 제공한다. 생성된 조건은 일반적으로 다음과 같고, 각각을 상태 비트, 조건 코드라고 한다.

- 올림수(C) : 연산 결과에 올림수가 있으면 1, 없으면 0으로 설정된다.
- 오버플로우(V) : 연산 결과에 오버플로우가 있으면 1, 없으면 0으로 설정된다.
- 부호(S) : 연산 결과가 음수이면 1, 양수 혹은 0이면 0으로 설정된다.
- 영(Z) : 연산 결과가 0이면 1, 0이 아니면 0으로 설정된다.

조건 분기 명령어는 다음과 같은 세 가지 유형이 있는데, 대부분의 아키텍처는 이 세 가지 중 하나 이상을 지원한다.

- 묵시적으로 조건을 생성하고, 별도의 명령어를 사용하여 분기 작업을 수행한다.
- 명시적으로 조건을 생성하고, 별도의 명령어를 사용하여 분기 작업을 수행한다.
- 비교와 분기 작업을 하나의 명령으로 수행한다.

## 프로시저의 호출과 복귀

프로시저란 특정 작업을 하나의 패키지처럼 수행하기 위한 일련의 명령어를 의미한다.  프로시저는 다음과 같은 장점이 있다.

- 프로그램 내의 중복된 코드를 없애준다.
- 프로그램 구현의 상세 내역을 숨겨준다.
- 명령어 그룹을 프로시저의 이름으로 나타내기 때문에 프로그램의 의미를 쉽게 파악할 수 있다.

프로시저를 사용하면 호출 및 복귀에 따른 부담이 발생한다. 가상 컴퓨터에서 proc이라는 이름의 프로시저를 호출한다고 가정해보면

```
cal proc
```

proc은 어셈블리 과정을 거쳐 기계어로 바뀌면 프로시저가 위치한 주소로 변환된다. 명령어 인출 과정은 다른 명령어와 동일하지만, 명령어 실행 과정은 다음 두 가지를 수행한다.

- proc 프로시저의 실행이 종료되면 'cal proc' 다음 명령어로 돌아와야 하기 때문에 복귀 주소를 저장한다.
- proc라는 프로시저로 분기한다.

프로시저 호출 명령의 실행 과정을 정리하면 다음과 같다.

- 인출 사이클 : IR <-M[PC]; PC<-PC + Δ (Δ는 명령어의 길이)
- 실행 사이클 : TOS <- PC; PC <- proc (TOS는 스택의 최상위 부분을 의미함)

실행 사이클의 첫번째 작업은 **다음에 실행할 명령어의 주소 값인 PC, 복귀 주소를 스택에 넣는 것**이다. 복귀 주소는 특정 레지스터, 프로시저의 시작 부분, 혹은 스택에 저장될 수 있다. 레지스터나 프로시저의 시작 부분에 저장할 경우, 프로시저를 중첩 호출하거나 재진입 가능한 프로시저를 호출할 수 없기 때문에, 일반적으로 복귀 주소는 스택을 사용하여 보관한다.

프로시저에 포함된 명령어를 모두 실행하고 종료하면 호출 프로그램으로 복귀해야 하는데 이를 위한 가상 컴퓨터의 명령어는 다음과 같다.

```
ret
```

# 명령어와 CPU 기억장치

CPU 내부에 기억 장치가 없는 가상의 컴퓨터를 메모리-메모리 컴퓨터라고 한다. 모든 데이터가 CPU 내부에 기억되지 않고 메모리에서 CPU를 경유하여 메모리로 전송된다. 그렇기 때문에 데이터가 필요한 경우 명령어의 피연산자 필드에 메모리 전체 주소를 명시해야 한다.

메모리-메모리 컴퓨터에서는 명령어를 실행할 때마다 CPU와 메모리 사이에 메모리 트래픽이 발생한다. 다음을 가정하여 폰노이만 병목에 발생하는 트래픽을 분석해본다.

- 연산 부호 크기는 1바이트
- 연산마다 최대 2개의 피연산자 필드
- 첫 번째 피연산자 필드는 근원지 및 목적지 겸용
- 메모리 주소는 2바이트
- 데이터 크기는 4바이트

해당 가정은 다음의 의미를 가진다

- 명령어는 최대 2^8, 256개이다.
- 데이터는 4바이트 단위로 취급하기 때문에 워드 크기는 4바이트이다.
- 메모리 주소가 16비트 이므로 최대 2^16워드 용량의 메모리를 사용할 수 있다.

해당 컴퓨터에서 다음 연산을 수행할 때 발생하는 메모리 트래픽을 계산해본다.

![연산](https://latex.codecogs.com/gif.latex?y&space;=&space;ax^2&space;&plus;&space;bx&space;&plus;&space;c)

다음은 주어진 아키텍처를 만족하는 가상의 어셈블리어를 사용하여 수행할 연산을 프로그래밍한 표이다.

| 명령어   | 의미                                     |
| -------- | ---------------------------------------- |
| mov y, a | y <- M[a]                                |
| mul y, x | y <- M[a] x M[x]                         |
| mul y, x | y <- M[a] x M[x]^2                       |
| mov t, b | t <- M[b]                                |
| mul t, x | t <- M[b] X M[x]                         |
| add y, t | y <- M[a] X M[x] ^2 + M[b] + M[x]        |
| add y, c | y <- M[a] X M[x] ^2 + M[b] + M[x] + M[c] |

트래픽 발생량을 알아본다.

모든 명령어는 연산 부호와 2개의 피연산자를 가지고 있다. 변수 a, t, x 등은 모두 피연산자로 데이터가 위치한 메모리 주소를 명시하고, M[a], M[x] 등은 메모리 a번지, x번지에 있는 데이터를 의미한다.

위의 가정으로, 명령어는 1바이트의 연산 부호와 2바이트의 피연산자 주소 2개로 구성되므로 명령어의 크기는 5 바이트다. 7개의 명령어를 메모리에서 인출해야 하므로 CPU와 메모리 사이에 35바이트의 트래픽이 발생한다.



연산을 수행할 때 데이터 이동에 필요한 트래픽 발생량을 알아본다. 7개의 명령어는 두 종류의 연산으로 구분할 수 있다.

- 데이터를 한 장소에서 다른 장소로 이동하는 mov
- 두 장소의 메모리에서 데이터를 CPU로 가져와 연산한 후 그 결과를 메모리의 한 장소에 저장하는 mul과 add

명령어 'mov y, a'를 수행할 때 발생하는 트래픽은 메모리 a번지에 있는 데이터를 CPU로 가져와 메모리 y번지에 저장하는데, 하나의 데이터가 4바이트이므로 데이터 트래픽은 8바이트이다.

명령어 'mul y, x'를 수행할 때 발생하는 트래픽은 메모리 y번지와 x번지에 있는 데이터 2개를 CPU로 가져와 곱셈을 수행한 결과 데이터 1개를 메모리 y 번지에 저장하므로 데이터 트래픽은 12이다.

add 명령어는 mul 명령어와 동일한 데이터 트래픽이 발생한다.

결과적으로 정의된 컴퓨터 연산을 수행하는데 mov 명령어가 2개, mul 혹은 add 명령어가 5개이므로 총 데이터 트래픽은 76(= 8 x 2 + 12 x 5)바이트이다.

그러므로 명령어 인출에 35바이트, 데이터 전송에 76바이트로 총 메모리 트래픽은 111바이트이다.