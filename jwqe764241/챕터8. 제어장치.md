# 제어장치의 이해

## 제어장치

제어장치는 메모리에서 명령어를 가져와 해독한 후 시스템 전체에 제어신호를 보냄으로써 명령어의 지시대로 연산장치, 레지스터 파일, 메모리, 입출력장치가 동작하게 한다.  프로세서의 상태에 따라 각 기능장치에 보낼 제어 신호가 다를 수 있기 때문에 제어장치는 명령어 외에도 프로세서의 상태와 클록 펄스를 입력으로 받아들인다.

제어장치가 수행하는 기능을 정리하면 다음과 같다.

- 명령어 해독 : 명령어의 연산 부호를 해독한다.
- 제어 신호 생성 : 명령어의 연산 부호를 해독한 결과와 기능 필드, 상태 레지스터, 외부 신호 등과 같은 정보를 사용하여 명령어 실행에 필요한 제어 신호를 생성한다.
- 제어 신호 인가 : 데이터 경로를 구성하는 각종 장치에 생성된 제어 신호를 인가함으로써 명령어가 지시하는 작업을 수행하게 한다.

데이터 경로를 구성하는 기능장치는 규칙적이지만 제어장치는 불규칙적이고 전역적이다. 제어방식의 구현 방식은 크게 고정결선식 제어방식과 마이크로프로그래밍 제어방식이 있다.

## 마이크로 연산과 제어 신호

프로세서의 상태를 변경하는 동작의 기본 단위를 마이크로 연산 또는 원자 연산, 원시 연산이라고 한다.

마이크로 연산을 수행하려면 특정한 제어 신호가 필요하다. 제어 신호는 다양한 제어점에 인가되어 데이터의 흐름을 제어하거나 연산의 종류를 선택한다. ex) 스위치와 삼상 버퍼는 동일한 기능장치로서 제어 신호를 1로 인가할 경우에만 입력한 내용이 출력된다.

제어점은 제어 신호가 적용되는 지점으로 제어선이라고도 하며 다음과 같은 종류가 있다.

- 레지스터나 메모리의 읽기, 쓰기 신호를 적용하는 지점
- 연산장치에 연산의 종류를 인가하는 지점
- 멀티플렉서나 디멀티플렉서를 사용하여 기능장치를 연결하는 지점
- 스위치나 삼상 버퍼를 통해 기능장치나 버스를 연결하는 지점

## PROM과 PLA

제어장치에서 제어 신호를 생성하려면 복잡한 논리회로가 필요하다.  최근에는 제어장치가 복잡해짐에 따라 PLD를 사용한다. PLD를 사용하면 설계가 용이하고 공간을 절약하며 논리 게이트의 수를 줄일 수 있을 뿐만 아니라 비용도 절감할 수 있다. 오늘날 대부분의 컴퓨터는 대표적인 PLD인 PROM 혹은 PLA를 사용한다.

PROM은 디코더의 출력을 OR 게이트 배열의 입력과 연결하며, PLA는 AND 게이트 배열의 출력을 OR 게이트 배열의 입력과 연결하는 조합 논리회로이다. 디코더는 최소항이라는 특별한 곱의 항만 출력하므로 PROM은 PLA의 특별한 경우로 볼 수 있다.

> 이 외의 자세한 설명은 책 참고

# 제어장치 구현 방식

## 제어 신호의 생성

2비트로 구성된 연산 부호를 사용하여 1비트의 제어 신호를 생성하는 예

| 연산부호  | 00   | 01   | 10   | 11   |
| --------- | ---- | ---- | ---- | ---- |
| 제어 신호 | 0    | 0    | 0    | 1    |

위의 표 처럼 연산 부호를 해독하여 대응하는 제어 신호를 생성하려면 조합 논리회로나 PROM을 사용할 수 있다.  연산 부호 2비트를 AND 게이트의 입력으로 사용하면 AND 게이트의 출력은 원하는 제어 신호가 된다. 그리고 AND 게이트 대신에 1 X 4 PROM을 사용할 수 있는데 PROM에 (0, 0, 0, 1)의 데이터를 저장하고 연산 부호를 PROM의 주소로 사용하면 AND 게이트와 동일한 제어 신호를 생성한다.

출력될 제어 신호가 바뀌는 경우에는 AND 게이트와 같이 조합 논리회로를 사용하는 경우에는 다시 설계를 해야하지만 PROM을 사용하는 경우에는 PROM에 저장된 데이터를 다시 프로그래밍하면 되기 때문에 융통성이 높다.

## 제어장치 구현의 두 가지 방식

불규칙적이고 전역적인 제어회로는 고정결선식 제어 방식과 마이스코프로그래밍 제어 방식으로 구현할 수 있다.

- 고정결선식 제어 방식

  디코더를 통해 명령어 레지스터의 연산 부호를 해석한다. 조합 논리회로가 디코더의 출력과 플래그 레지스터, 외부 장치의 신호 등을 이용하여 각 기능장치나 버스의 제어점에 적절한 제어 신호를 클록에 맞춰 제공한다.

  명령어 구성이 복잡하거나 명령어의 수가 많아지면 제어 장치를 위한 조합 논리회로의 설계와 검증이 매우 복잡하고 어려워지기 때문에 오늘날은 조합 논리회로 대신에 PLA를 사용한다. 해당 제어 방식의 장단점은 다음과 같다.

  - 장점
    - 최적화할 수 있어서 일반적으로 제어 신호를 빠른 시간에 생성할 수 있다.
    - ROM과 달리 불필요한 회로를 제거할 수 있으므로 칩의 크기가 작다.
  - 단점
    - 연산 부호가 달라지거나 프로세서 상태를 추가해야 할 때 제어장치를 다시 설계해야됨

- 마이크로프로그래밍 제어 방식

  마이크로 연산을 수행할 수 있도록 마이크로 명령어를 PROM에 프로그래밍하는 방식이다. 모든 명령어는 연속된 마이크로 연산으로 분할되며, 일부 마이크로 연산은 동시에 수행될 수 있다. 동시에 수행되는 마이크로 연산의 집합을 마이크로 명령어 or 제어 단어라고 한다.

  고정결선식과 마찬가지로 연산 부호를 해석하기 위해 디코더를 포함한다. ROM에 저장된 마이크로 명령어를 사용하여 제어 신호를 생성하며, 클록 펄스에 맞춰 제어 신호를 기능장치나 버스의 제어점에 인가한다. 해당 제어 방식의 장단점은 다음과 같다.

  - 장점
    - 연산 부호가 바뀌거나 프로세서 상태가 추가될 경우 PROM에 수정된 내용을 프로그래밍 하면 되므로 명령어 집합의 변경이 가능하다.
    - 다른 종류의 명령어 집합을 에뮬레이션할 수 있다.
    - 동일한 시스템에 다수의 명령어 집합을 구현할 수 있다.
    - 컴퓨터의 구성, 타이밍, 기술의 변화에 쉽게 적응할 수 있다.
  - 단점
    - ROM을 사용하여 불필요한 회로가 포함되어 칩의 면적이 커진다.
    - ROM 메모리에 의해 속도가 제한된다.



# 마이크로프로그래밍 방식의 제어장치

## 마이크로 명령어의 구성 요소

데이터 경로의 제어점에 적용될 제어 신호의 모든 비트를 모으면 마이크로 명령어를 구성할 수 있고, 이런 마이크로 명령어를 수행하기 위해 PROM에 저장하며 순차적으로 실행할 수 있다. 마이크로 명령어를 저장하기 위한 PROM을 제어 저장소 or 제어 메모리라고 부른다.

마이크로 명령어는 다음과 같은 세 종류의 필드가 필요하다.

- 마이크로 연산 필드 : 모든 제어점에 대응하는 마이크로 연산으로 구성된다. 마이크로 명령어는 모든 제어점을 활성화 혹은 비활성화할 수 있도록 많은 마이크로 연산을 포함하는 고정 길이이다.
- 분기 조건 필드 : 마이크로 명령어의 실행 순서는 비순차적일 수도 있다. 분기할 조건을 마이크로 명령어에 포함해야 한다. 분기 조건이 참이면 다음 마이크로 명령어 주소 필드에 있는 마이크로 명령어를 수행하고 거짓이면 순차적으로 마이크로 명령어를 수행한다.
- 다음 마이크로 명령어 주소 필드 : 분기될 경우 실행해야 할 다음 마이크로 명령어의 주소를 포함하는 필드이다.

## 마이크로 명령어의 제어

제어 저장소는 마이크로 명령어를 그룹 단위로 구성하며, 기능에 따라 그룹이 결정된다. 이때 마이크로 명령어의 그룹을 제어 루틴이라고 한다. 제어 루틴은 특정 기능을 위해 순차적으로 수행되어야 할 마이크로 명령어의 집합니다.

모든 제어 루틴의 마지막은 다음에 수행될 제어 루틴으로 분기하는 마이크로 명령어를 포함한다. 

제어장치는 명령어가 의도하는 마이크로 명령어를 포함하는 제어 루틴에 순차적으로 접근함으로써 명령어에 대한 제어 신호를 생성한다. 제어 저장소에 있는 마이크로 명령어를 순차적으로 읽기위해 마이크로프로그램 계수기를 사용한다.

제어장치는 순서 제어 모듈을 사용하여 제어 저장소에 있는 마이크로프로그램의 시작 주소를 생성한 후 마이크로프로그램 계수기로 보낸다.  순서 제어 모듈은 마이크로 명령어를 실행할 때마다 마이크로프로그램 계수기를 하나씩 증가시켜 마이크로 명령어를 순차적으로 수행시킨다. 그러나다음과 같은 경우에는 마이크로프로그램 계수기를 갱신하고 비순차적으로 마이크로 명령어를 실행시킨다.

- 새로운 명령어가 명령어 레지스터에 적재된 경우
- 분기 마이크로 명령어가 분기 조건을 만족할 경우
- 제어 루틴의 마지막 마이크로 명령어를 실행할 경우

## 마이크로 명령어의 형식

데이터 경로에 적용할 제어 신호의 코딩 방법에 따라 다음과 같이 분류된다.

- 수평적 마이크로 명령어
  - 마이크로 연산 필드의 모든 비트를 제어 신호와 일대일로 대응시키는 방식으로 제어점에 그대로 인가할 수 있다.
  - 마이크로 명령어의 길이가 길어서 큰 용량의 제어 저장소, 특히 넓은 폭의 제어 저장소를 필요로 한다.
  - 하드웨어가 간단해지고 명령어 해독에 따른 지연 시간이 없어서 속도가 빠르다.
- 수직적 마이크로 명령어
  - 마이크로 연산 필드를 인코더로 압축하여 마이크로 명령어의 길이를 줄인 방식이다. 디코더를 사용하여 마이크로 연산 필드의 내용을 해독해야 데이터 경로의 제어점에 인가할 제어 신호가 된다.
  - 마이크로 명령어의 길이가 짧아서 좁은 폭의 제어 저장소를 필요로 한다.
  - 디코더를 사용해야 하므로 속도가 느리다.



# 단일 사이클 방식 데이터 경로를 위한 제어장치

## 제어 신호의 종류

제어 신호의 종류는 다음과 같다. 아래의 6개는 직관적인 제어 신호이다.

- 명령어 메모리, 데이터 메모리, 레지스터 파일, PC에 대한 읽기 제어 신호 (IMemRd, DMemRd, RegRd, PCRd)
- 명령어 메모리의 경우 읽기 작업만 수행하므로 쓰기에 관련된 제어 신호 (IMemWr)
- 명령어를 실행할 때마다 PC는 항상 갱신되어야 하므로 PC의 쓰기에 관련된 제어 신호 (PCWr)

다음은 나머지 제어신호의 설명이다.

- RegDest
  - 0 : 명령어의 rt 필드를 레지스터 쓰기 단자의 주소로 사용
  - 1 : 명령어의 rd 필드를 레지스터 쓰기 단자의 주소로 사용
- RegWr
  - 0 : 레지스터 파일에 데이터 쓰기 금지
  - 1 : 레지스터 파일에 데이터 쓰기 허용
- ALUSrc
  - 0 : 레지스터 파일의 두 번째 데이터 출력을 ALU 하단의 데이터로 사용
  - 1 : 명령어의 imm 필드를 확장한 데이터를 ALU 하단의 데이터로 사용
- SignExt
  - 0 : 명령어의 imm 필드를 0-확장
  - 1 : 명령어의 imm 필드를 부호 확장
- Immx2
  - 0 : 시프트 금지
  - 1 : 명령어의 imm 필드를 1비트 왼쪽으로 시프트
- ALUCtr
  - 000 : 논리곱
  - 001 : 논리합
  - 010 : 덧셈
  - 011 : 뺄셈
- MemWr
  - 0 : 메모리에 데이터 쓰기 금지
  - 1 : 메모리에 데이터 쓰기 허용
- Mem2Reg
  - 0 :  ALU의 출력을 레지스터 쓰기 단자의 데이터로 사용
  - 1 : 메모리의 출력을 레지스터 쓰기 단자의 데이터로 사용
- PCSrc
  - 00 : PC + 2 출력
  - 01 : PC + 2 + imm X 2 출력
  - 1x : PC + 2 + addr X 2 출력 

## 명령어 실행을 위한 마이크로 연산과 제어 신호

> ~형식 명령어의 설명이므로 책 참고

## 제어장치 구현

picoMIPS 프로세서를 예로  이 프로세서를 위한 제어장치는 주 제어부와 보조 제어부로 구성된다. 주 제어부는 시스템 전반을 위한 제어 신호를 생성하고, 보조 제어부는 연산장치에 필요한 제어 신호를 준비한다.

주 제어부는 연산 부호 4비트를 해독해 8가지의 제어 신호와 보조 제어부에 보낼 ALUOp 신호를 생성하고, ALUOp 신호는 명령어의 종류에 따라 네 가지 그룹을 나타내기 위해 2비트로 구성된다.  보조 제어부는 명령어 종류에 따라 다음의 그룹으로 구분하여 명령어에 필요한 제어 신호를 ALUCtr를 ALU에 보낸다.

- R-형식 명령어 : 기능 필드가 명시하는 산술 및 논리 제어 신호
- I-형식 적재 저장 명령어 또는 분기 명령어 : 메모리 주소 계산을 위한 덧셈 제어 신호
- I-형식 산술 또는 논리 명령어 : 산술 또는 논리 제어 신호
- I-형식 분기 명령어 : 두 레지스터를 비교하기 위한 밸셈 제어 신호

> 나머지 부분은 제어 신호를 생성하는 방식을 설명하기 때문에 책 참고



# 다중 사이클 방식 데이터 경로를 위한 제어장치

## 제어 신호의 종류

- RegAddr 
  - 0 : IR 레지스터의 rt 필드를 레지스터 쓰기 단자의 주소로 사용
  - 1 : IR 레지스터의 rd 필드를 레지스터 쓰기 단자의 주소로 사용
- RegData
  - 0 : DR 레지스터를 레지스터 쓰기 단자의 데이터로 사용
  - 1 : C 버퍼를 레지스터 쓰기 단자의 데이터로 사용
- ALUSrc1
  - 0 : PC를 ALU 상단의 데이터로 사용
  - 1 : A 버퍼를 ALU 상단의 데이터로 사용
- ALUSrc2
  - 00 : B 버퍼를 ALU 하단의 데이터로 사용
  - 01 : 2를 ALU 하단의 데이터로 사용
  - 10 : IR 레지스터의 addr 필드를 부호 확장한 후 1비트 왼쪽으로 시프트한 데이터를 ALU 하단의 데이터로 사용
  - 11 : IR 레지스터의 imm 필드를 부호 확장 혹은 0-확장한 데이터를 ALU 하단의 데이터로 사용
- SignExt
  - 0 : IR 레지스터의 imm 필드를 0-확장
  - 1 : IR 레지스터의 imm 필드를 부호 확장
- Immx2
  - 0 : 데이터를 그대로 MUX에 입력
  - 1 : 데이터를 1비트 왼쪽으로 시프트한 후 MUX에 입력

## 명령어 실행을 위한 마이크로 연산과 제어 신호

> 책 참고할 것