# 피연산자의 수와 명령어 집합

## 누산기 컴퓨터

메모리-메모리 컴퓨터는 CPU 내부에 데이터를 저장하는 기억장치가 없는데, 이 컴퓨터에 하나의 데이터를 저장하기 위한 레지스터를 추가한 컴퓨터를 누산기 컴퓨터라 하고, 그 레지스터를 누산기라고 한다. 누산기 컴퓨터는 다음과 같은 특징을 갖는다.

- 누산기를 묵시적 피연산자로 사용한다.
- 적재 혹은 저장 명령어가 아니면 누산기는 근원지 겸 목적지 레지스터로 사용된다.
- 메모리를 명시적 피연산자로 사용한다.
- 누산기 컴퓨터는 CPU 내에 기억장치가 하나의 워드 용량인 누산기만 있으므로 단순하고 저렴하다.

## 스택 컴퓨터

스택 컴퓨터는 CPU 내부에 다수의 데이터를 임시로 저장하기 위해 스택을 사용하는 컴퓨터를 말한다. 스택 컴퓨터는 다음과 같은 특징을 가지고 있다.

- 스택에 저장된 모든 데이터는 위치에 따라 접근 시간이 다르다.
- 대부분의 연산은 스택의 최상위 또는 차상위 데이터를 사용하여 수행한다.
- 최근 연산한 데이터는 스택의 최상위에 저장된다.
- 보관할 데이터의 양이 스택 용량보다 크면 스택의 최하위에 있는 데이터부터 삭제해야 하므로 성능이 떨어진다.

스택 컴퓨터는 메모리에 접근하기 위해 다음과 같은 명령어를 사용한다.

- push : 메모리에서 스택의 최상위로 데이터를 이동하는 명령어
- pop: 스택의 최상위에 있는 데이터를 메모리로 이동하는 명령어

## 범용 레지스터 컴퓨터

범용 레지스터 컴퓨터는 CPU 내부에 다수의 데이터를 임시로 저장하기 위해 범용 레지트서를 사용하는 컴퓨터를 말한다. 범용 레지스터 컴퓨터는 다음과 같은 특징을 가지고 있다.

- 범용 레지스터는 스택과 달리 모든 레지스터의 접근 시간이 동일하며, 순서에 상관없이 임의로 접근할 수 있다.
- 누산기나 스택과 달리 레지스터가 명시적 피연산자로 사용된다.

범용 레지스터 컴퓨터다 다음 명령어만 메모리에 접근할 수 있도록 제한하는 경우 적재-저장 명령어 컴퓨터라고 한다.

- 적재 명령어 : 데이터를 메모리에서 CPU 레지스터로 전송
- 저장 명령어 : 데이터를 CPU 레지스터에서 메모리로 전송



# 명령어와 메모리

## 메모리 속성

메모리 구성 요소에는 대표적으로 다음이 있다.

- 워드 : 명령어와 데이터를 포함할 수 있는 메모리 구성 요소중 하나이다. 워드는 고정된 개수의 비트라는 메모리 소자로 이루어진다.
- 주소 : 메모리는 주소라는 고유의 번호를 사용하여 명령어나 데이터를 참조한다.
- 주소 지정 단위 : 주소 해상도를 결정하는 것이다. 주소 해상도는 아키텍처가 직접 명시할 수 있는 정보의 최소 단위를 명시한다.

## 메모리 정렬

 **정렬된 메모리는 주소 해상도가 바이트라 할지라도 명령어와 데이터를 강제로 정렬하는 방식**을 뜻한다. 쉽게 말하자면 2바이트로 구성된 명령어와 데이터는 2의 배수로 시작되는 주소를 갖고, 4바이트로 구성된 명령어와 데이터는 4의 배수로 시작되는 주소를 갖도록 강제하는 방식이다. 이는 **컴퓨터를 구현할 때 실행 속도를 높이기 위한 요구사항이다.** 

정렬되지 않은 워드 데이터를 적재하려면 2개의 메모리 읽기 사이클을 실행해야 하지만, 정렬되어 있다면 1개의 메모리 읽기 사이클만 수행하면 된다. 그렇기 때문에 대부분의 아키텍처는 명령어나 데이터를 정렬함으로써 성능을 높인다.

## 엔디언 방식

**엔디언은 여러 개의 연속된 대상을 1차원 공간에 배열하는 방법을 말한다.** 엔디언 방식에서 비트, 바이트, 워드의 순서는 어느 방법이든 성능에 차이가 없다고 알려져 있다. 그러나 컴파일된 실행 파일을 다른 아키텍처로 이식할 때는 워드 내부의 비트 혹은 바이트의 순서가 달라지기 때문에 의미가 있다.



# 주소 지정 방식

**주소 지정 방식은 명령어의 일부인 피연산자 필드를 사용하여 데이터가 실제 위치한 유효 주소를 결정하는 방법이다.** 주소 지정 방식은 피연산자 정보를 가지고 몇 단계를 걸쳐 원하는 데이터에 접근할 수 있느냐에 따라 단계별로 분류할 수 있다.

일반적으로 주소 확정을 위한 단계가 깊을수록 데이터를 참조하는 데 시간이 오래 걸리지만, 더 많은 데이터를 다양한 방법으로 보관할 수 있다는 장점도 있다.

명령어의 피연산자 필드와 데이터 실제 위치의 관계를 나타내기 위해 다음과 같은 표기를 사용한다.

- r : 명령어 내의 피연산자 필드가 명시하는 레지스터 주소
- a : 명령어 내의 피연산자 필드가 명시하는 메모리 주소
- ea : 참조되는 데이터를 포함하는 장소의 실제 주소, 즉 유효 주소
- Reg[x] : 레지스터 x의 내용
- M[x] : 메모리 x번지의 내용

## 0-단계 주소 지정 방식

0-단계 주소 지정 방식은 데이터가 있는 위치를 파악하기 위해 특별한 과정이 필요 없는 방식으로 데이터의 유효 주소를 명시하지 않는다. 0-단계 주소 지정 방식에는 다음이 있다.

- 즉치 주소 지정 (immediate addressing mode) : 명령어의 피연산자 필드에 데이터가 포함되어 있으므로 주소 지정과는 상관이 없다. 따라서 명령어를 CPU로 인출만 하면 데이터가 바로 보이기 때문에 데이터를 즉시 이용할 수 있다. 
- 묵시 주소 지정 (implied addressing mode) : 누산기나 프로그램 계수기 등과 같은 정해진 기억장치에 데이터가 저장된다. 이 방식은 항상 정해진 장소에 데이터가 있기 때문에 데이터의 위치를 명시할 필요가 없다.

## 1-단계 주소 지정 방식

1-단계 주소 지정 방식은 데이터의 위치, 즉 유효 주소를 확정하기 위해 주소 계산이나 읽기 연산 과정을 한 번 수행하는 방식이다. 1-단계 주소 지정 방식부터는 데이터의 위치를 확정하기 위해 명령어의 피연산자 필드를 주소로 사용한다.

- 레지스터 직접 주소 지정 (register-direct addressing) : 데이터가 레지스터 파일 중의 한 곳에 있고 데이터가 있는 레지스터의 주소를 명령어의 피연산자 필드에 명시하는 방식이다. 이 방식은 높은 효율과 빠른 속도로 대부분의 아키텍처에서 사용된다. 이 방식의 데이터 주소 확정 과정은 다음과 같이 나타낼 수 있다.
  ea = r
- 직접 주소 지정 (direct addressing) : 데이터가 있는 메모리의 주소를 명령어의 피연산자 필드에 명시하는 방식이다. 데이터를 참조하려면 피연산자 필드에 명시된 메모리 주소를 사용하여 메모리에 접근하면 된다. 메모리 주소 공간 전체를 사용하려면 메모리의 절대 주소 길이 만큼 긴 피연산자 필드가 필요하므로 명령어가 너무 길어진다. 이 방식의 데이터 주소 확정 과정은 다음과 같이 나타낼 수 있다.
  ea = a

## 2-단계 주소 지정 방식

2-단계 주소 지정 방식은 데이터의 유효 주소를 확정하기 위해 주소 계산이나 읽기 연산 과정을 두 번 수행한다. 이 방식은 데이터가 메모리에 저장되므로 많은 데이터의 위치를 명시할 수 있다. 그러나 데이터의 주소를 확정하기 위해 2-단계 과정을 거쳐야 하므로 0-단계, 1-단계 주소 지정 방식보다 데이터를 참조하는 데 더 많은 시간이 걸린다.

- 레지스터 간접 주소 지정 (register-indirect addressing) :  피연산자 필드가 레지스터 주소를 명시하며, 레지스터의 내용이 데이터를 위한 메모리의 주소를 명시한다. 이 방식의 데이터 주소 확정 과정은 다음과 같이 나타낼 수 있다
  ea = Reg[r]
- 메모리 간접 주소 지정 (memory-indirect addressing) : 데이터가 있는 메모리 주소를 간접적으로 명령어의 피연산자 필드에 명시하는 방식이다. 이 방식의 데이터 주소 확정 과정은 다음과 같이 나타낼 수 있다
  ea = M[a]
- 변위 주소 지정 (displacement addressing): 명령어에 포함된 2개의 피연산자 필드를 사용하여 데이터가 있는 주소를 확정하는 방식이다. 이 방식의 데이터 주소 확정 과정은 다음과 같이 나타낼 수 있다.
  ea = Reg[r] + a
  이 방식은 색인 주소 지정과 베이트 주소 지정이 있다.
  - 색인 주소 지정 (indexed addressing) : 2개의 피연산자 필드 중 하나는 베이스 주소로 사용할 메모리 주소를 포함하고, 다른 하나는 변윗값으로 사용할 색인 레지스터 주소를 명시한다.
  - 베이스 주소 지정 (base addressing) : 2개의 피연산자 필드 중 하나는 베이스 주소로 사용할 베이스 레지스터 주소를 명시하고, 다른 하나는 변윗값으로 사용할 메모리 주소를 명시한다.

- PC 상대 주소 지정 (PC-relative addressing) : 베이스 레지스터로 프로그램 계수기를 사용하는 베이스 주소 지정의 특별한 경우에 해당되는데, 이 방식은 프로그램 계수기를 명시할 필요가 없으므로 변위 주소를 명시할 하나의 피연산자 필드만 있으면 된다. 이 방식의 데이터 주소 확정 과정은 다음과 같이 나타낼 수 있다
  ea = PC + a



# 복잡도에 따른 명령어 집합

## CISC의 탄생과 특징

초기의 컴퓨터는 두 가지 문제가 있었다.

- 메모리가 매우 고가이고 속도가 느렸음
- 프로그래밍 기술이 발전되지 않아서 소프트웨어 개발에 어려움이 있었다.

당시에는 **메모리 용량을 작게 차지하는 프로그램을 구성할 수 있어야 좋은 아키텍처**였고, 또한 프로그래밍 기술이 발전하기 이전이었기 때문에 소프트웨어 개발 비용도 만만치 않아서 **강력하고 복잡한 고급 프로그래밍 언어가 개발되고 고급언어를 잘 지원하도록 강력한 명령어를 추가한 컴퓨터를 설계**하게 되었다.

이러한 상황으로 컴퓨터 제조 회사들은 새롭고 더욱 강력한 모델로 명령어 집합의 크기를 계속 증가시켰는데, 이와 같은 강력한 모델의 명령어 집합 구조를 **복합 명령어 집합 구조**(CISC complex instruction set computer)라고 한다. 

CISC 구조를 사용하면 명령어를 효율적으로 인출할 수 없고 데이터 전송 효율도 나빠진다. 이의 원인은 다음과 같다.

- 높은 코드 밀도와 강력한 명령어를 추구하기 위해 가변 명령어 형식을 사용하였다.
  - 가변 명령어 형식은 많은 종류의 주소 지정 방식을 동반하였다.
  - 연산 부호를 해독할 때까지 명령어의 길이를 알 수 없다.

## RISC의 탄생

프로그램의 실행 궤적을 사용하여 CISC 구조의 실효성에 대한 연구가 진행되었고, 연구 결과에 의하면 CISC구조의 연산과 주소 지정 방식의 사용 빈도가 매우 낮으며 일부 데이터 형식은 거의 사용되지 않는 것으로 나타났다. 또한 컴파일러도 CISC 구조의 강력한 명령어 집합을 일부만 사용할 가능성이 크다.

CISC 구조로 인한 영향은 다음과 같다.

- 복잡한 연산이 CPU 설계에 영향을 미친다.
- 복잡한 피연산자 구조가 메모리 구성과 주소 지정 방식에 영향을 미친다.
- 복잡한 프로그램 제어는 제어장치의 구성과 파이프라인 구현에 영향을 미친다.
- 복잡하고 강력한 명령어의 집합은 오히려 간단한 명령어를 포함한 모든 명령어의 해석과 실행 시간을 증가시킨다.

복잡하고 강력한 연산을 거의 사용하지 않기 때문에 이러한 명령어를 명령어 집합에 포함하는 것이 바람직하지 못하다고 생각하여 다른 시각으로 명령어 구조 집합 구조에 접근하기 시작했다.

단순한 명령어는 하나의 사이클 내에서 실행될 수 있으며, 짧은 사이클 시간도 허용한다. 그렇기 때문에 컴퓨터 설계자들은 단순한 연산, 단순한 주소 지정 방식, 작은 상수의 즉치 피연산자 혹은 변윗값, 소수의 데이터 형식, 소수의 명령어 형식을 사용하는 컴퓨터를 설계하였다. 즉, 명령어 집합 구조가 컴파일러에 대해 해결책 대신 기본 명령어를 제공하도록 했다.

추가적으로 메모리의 지속적인 가격 하락은 코드 밀도의 중요성을 떨어뜨리고, 메모리의 속도 향상은 폰노이만 병목에 대한 영향을 줄여준다. 궁극적으로 고급언어에 가까운 명령어를 제공함으로써 생기는 **시멘틱 갭(고급 언어로 표현한 것과 실제로 수행한 연산이 상반되는 것)의 축소는 성능에 악영향을 미칠 수 있다**.

## RISC의 특징

강력하고 복합적인 명령어가 아니라 단순하지만 더 빨리 실행되는 소수의 명령어를 사용하는 아키텍처를 축약 명령어 집합 구조 (RISC reduced instruction set computer)라고 한다.

RISC 방식은 다음과 같은 특징을 가지고 있어 CPI와 사이클 시간이 줄어든다.

- 단순 명령어 : 전형적으로 하나의 사이클 내에서 실행되기 때문에 실행 속도가 빠르다.
- 짧은 사이클 시간 : 단순 명령어를 실행하는 데이터 경로가 간단하므로 명령어 실행에 필요한 사이이클 시간이 짧다.
- 적재, 저장 구조 : 적재 및 저장 명령어를 통해서만 메모리의 접근을 허용하며, 나머지 명령어는 메모리에 접근할 수 없고 오로지 레지스터 기반으로 연산을 한다. 자주 접근하는 데이터가 레지스터에 저장되어 있으므로 데이터 인출 시간이 짧아진다.
- 고정 길이 명령어 : 명령어 길이가 고정되어 있어 명령어를 해독하기 전에 다음 명령어의 주소를 알 수 있다. 따라서 명령어 인출 과정이 단순하고 빠르다.
- 단순 명령어 형식 : 명령어 형식이 단순하여 명령어를 빨리 해독할 수 있다.
- 제한된 종류의 주소 지정 방식 : 데이터의 유효 주소를 계산할 필요가 없거나 유효 주소에 대한 계산 속도를 향상할 수 있다.
- 하버드 아키텍처 : 명령어와 데이터가 독립적인 경로를 사용하기 때문에 메모리 대역폭이 증대된다.

## RISC와 CISC의 전망

CISC 구조의 명령어는 고급언어에 가까운 구조로서 하드웨어를 강조하지만, RISC 구조의 명령어는 기계어에 가까운 구조로서 소프트웨어를 강조한다. 

컴퓨터 성능에 의하면 최종적으로 고려해야 할 것은 CPI나 사이클 시간이 아니라 애플리케이션의 실행 시간이기 때문에 오늘날의 컴퓨터는 RISC 구조와 CISC 구조의 장점을 통합하는 추세이다.

| 구분           | RISC                                    | CISC                        |
| -------------- | --------------------------------------- | --------------------------- |
| 명령어 형식    | 고정적                                  | 가변적                      |
| 명령어 종류    | 적음                                    | 많음                        |
| 명령어 길이    | 고정적                                  | 가변적                      |
| 적재 저장 구조 | 사용                                    | 미사용                      |
| 주소 지정 방식 | 단순하고 소수                           | 복잡하고 다수               |
| 회로구성       | 단순함                                  | 복잡함                      |
| 장점           | 구현 용이, 파이프라이닝에의 효율적 적용 | 호환성 양호, 코드 밀도 양호 |
| 예             | MPIS, ARM, PowerPC                      | 인텔 x86, DEC VAX 11/780    |



# picoMIPS 명령어 집합 구조

## picoMIPS의 개요

picoMIPS 아키텍처는 다음과 같은 특징을 가지고 있다.

- 16비트 아키텍처로 워드의 길이가 16비트이다.
- 기본적으로 3-주소 명령어 형식을 사용한다.
- 적재 저장 명령어 구조이기 때문에 적재 명령어와 저장 명령어만 메모리에 접근할 수 있고 나머지 명령어는 레지스터에 복제된 데이터만 처리할 수 있다.
- 바이트 순서는 빅 엔디언 방식을 사용한다. 워드 내의 비트 번호는 최소 유효 비트에서 시작하므로 가장 오른쪽 비트가 비트 번호 0이다.
- 데이터는 메모리에 정렬되어 저장된다. 따라서 명령어를 참조하거나 워드 크기의 데이터를 참조하려면 한 번의 메모리 접근만 필요하다.
- 레지스터가 8개이므로 레지스터의 주소를 명시하기 위해 3비트를 사용한다.

## picoMIPS의 명령어 형식과 종류

모든 picoMIPS 명령어는 16비트로 구성된다. 그리고 다음의 세 가지 명령어의 형식을 하용한다.

- R-형식 명령어 : rs(register source)와 rt(register target) 필드에 명시된 2개의 레지스터를 사용하여 연산하며, 결과를 rd(register destination) 필드에 명시된 레지스터에 저장한다. 기능 필드(**fn** function)는 연산 부호를 확장하기 위한 필드로 산술논리장치가 수행할 연산을 정의한다. 따라서 R-형식의 명령어는 다음과 같은 연산을 수행한다. 함수 f()는 연산 부호와 기능 필드를 사용하여 해독된 연산을 의미한다.
  - Reg[rd] <- f(Reg[rs], Reg[rt])
- I-형식 명령어 :  6비트로 구성된 imm 필드를 포함한다. 이 필드는 즉칫값을 명시하며 -32에서 31 사이의 상수를 나타낼 수 있다. I-형식 명령어는 명령어의 종류마다 다음과 같은 연산을 수행한다.
  - 적재 명령어 : Reg[rt] <- M[Reg[rs] + imm x 2]
  - 저장 명령어 : M[Reg[rs] + imm x 2] <- Reg[rt]
  - 조건 분기 명령어 : if(condition(Reg[rs], Reg[rt]) == true) then PC <- PC + 2 + imm x 2
  - 기타 명령어 : Reg[rt] <- f(Reg[rs], imm)
- J-형식 명령어 :  무조건 분기 명령어에서 사용되며, 다음과 같은 addr 필드에 명시된 워드 주소 값을 사용하여 PC 상대 지정 방식으로 분기한다. R-형식의 조건 분기 명령어와 마찬가지로 addr은 워드 주소를 의미하므로 다음과 같이 addr x 2를 사용하여 프로그램 계수기를 갱신한다.
  - 무조건 분기 명령어 : PC <- PC + 2 + addr x 2