# 피연산자의 수와 명령어 집합

## 누산기 컴퓨터

메모리-메모리 컴퓨터는 CPU 내부에 데이터를 저장하는 기억장치가 없는데, 이 컴퓨터에 하나의 데이터를 저장하기 위한 레지스터를 추가한 컴퓨터를 누산기 컴퓨터라 하고, 그 레지스터를 누산기라고 한다. 누산기 컴퓨터는 다음과 같은 특징을 갖는다.

- 누산기를 묵시적 피연산자로 사용한다.
- 적재 혹은 저장 명령어가 아니면 누산기는 근원지 겸 목적지 레지스터로 사용된다.
- 메모리를 명시적 피연산자로 사용한다.
- 누산기 컴퓨터는 CPU 내에 기억장치가 하나의 워드 용량인 누산기만 있으므로 단순하고 저렴하다.

## 스택 컴퓨터

스택 컴퓨터는 CPU 내부에 다수의 데이터를 임시로 저장하기 위해 스택을 사용하는 컴퓨터를 말한다. 스택 컴퓨터는 다음과 같은 특징을 가지고 있다.

- 스택에 저장된 모든 데이터는 위치에 따라 접근 시간이 다르다.
- 대부분의 연산은 스택의 최상위 또는 차상위 데이터를 사용하여 수행한다.
- 최근 연산한 데이터는 스택의 최상위에 저장된다.
- 보관할 데이터의 양이 스택 용량보다 크면 스택의 최하위에 있는 데이터부터 삭제해야 하므로 성능이 떨어진다.

스택 컴퓨터는 메모리에 접근하기 위해 다음과 같은 명령어를 사용한다.

- push : 메모리에서 스택의 최상위로 데이터를 이동하는 명령어
- pop: 스택의 최상위에 있는 데이터를 메모리로 이동하는 명령어

## 범용 레지스터 컴퓨터

범용 레지스터 컴퓨터는 CPU 내부에 다수의 데이터를 임시로 저장하기 위해 범용 레지트서를 사용하는 컴퓨터를 말한다. 범용 레지스터 컴퓨터는 다음과 같은 특징을 가지고 있다.

- 범용 레지스터는 스택과 달리 모든 레지스터의 접근 시간이 동일하며, 순서에 상관없이 임의로 접근할 수 있다.
- 누산기나 스택과 달리 레지스터가 명시적 피연산자로 사용된다.

범용 레지스터 컴퓨터다 다음 명령어만 메모리에 접근할 수 있도록 제한하는 경우 적재-저장 명령어 컴퓨터라고 한다.

- 적재 명령어 : 데이터를 메모리에서 CPU 레지스터로 전송
- 저장 명령어 : 데이터를 CPU 레지스터에서 메모리로 전송



# 명령어와 메모리

## 메모리 속성

메모리 구성 요소에는 대표적으로 다음이 있다.

- 워드 : 명령어와 데이터를 포함할 수 있는 메모리 구성 요소중 하나이다. 워드는 고정된 개수의 비트라는 메모리 소자로 이루어진다.
- 주소 : 메모리는 주소라는 고유의 번호를 사용하여 명령어나 데이터를 참조한다.
- 주소 지정 단위 : 주소 해상도를 결정하는 것이다. 주소 해상도는 아키텍처가 직접 명시할 수 있는 정보의 최소 단위를 명시한다.

## 메모리 정렬

 **정렬된 메모리는 주소 해상도가 바이트라 할지라도 명령어와 데이터를 강제로 정렬하는 방식**을 뜻한다. 쉽게 말하자면 2바이트로 구성된 명령어와 데이터는 2의 배수로 시작되는 주소를 갖고, 4바이트로 구성된 명령어와 데이터는 4의 배수로 시작되는 주소를 갖도록 강제하는 방식이다. 이는 **컴퓨터를 구현할 때 실행 속도를 높이기 위한 요구사항이다.** 

정렬되지 않은 워드 데이터를 적재하려면 2개의 메모리 읽기 사이클을 실행해야 하지만, 정렬되어 있다면 1개의 메모리 읽기 사이클만 수행하면 된다. 그렇기 때문에 대부분의 아키텍처는 명령어나 데이터를 정렬함으로써 성능을 높인다.

## 엔디언 방식

**엔디언은 여러 개의 연속된 대상을 1차원 공간에 배열하는 방법을 말한다.** 엔디언 방식에서 비트, 바이트, 워드의 순서는 어느 방법이든 성능에 차이가 없다고 알려져 있다. 그러나 컴파일된 실행 파일을 다른 아키텍처로 이식할 때는 워드 내부의 비트 혹은 바이트의 순서가 달라지기 때문에 의미가 있다.



# 주소 지정 방식

**주소 지정 방식은 명령어의 일부인 피연산자 필드를 사용하여 데이터가 실제 위치한 유효 주소를 결정하는 방법이다.** 주소 지정 방식은 피연산자 정보를 가지고 몇 단계를 걸쳐 원하는 데이터에 접근할 수 있느냐에 따라 단계별로 분류할 수 있다.

일반적으로 주소 확정을 위한 단계가 깊을수록 데이터를 참조하는 데 시간이 오래 걸리지만, 더 많은 데이터를 다양한 방법으로 보관할 수 있다는 장점도 있다.

명령어의 피연산자 필드와 데이터 실제 위치의 관계를 나타내기 위해 다음과 같은 표기를 사용한다.

- r : 명령어 내의 피연산자 필드가 명시하는 레지스터 주소
- a : 명령어 내의 피연산자 필드가 명시하는 메모리 주소
- ea : 참조되는 데이터를 포함하는 장소의 실제 주소, 즉 유효 주소
- Reg[x] : 레지스터 x의 내용
- M[x] : 메모리 x번지의 내용

## 0-단계 주소 지정 방식

0-단계 주소 지정 방식은 데이터가 있는 위치를 파악하기 위해 특별한 과정이 필요 없는 방식으로 데이터의 유효 주소를 명시하지 않는다. 0-단계 주소 지정 방식에는 다음이 있다.

- 즉치 주소 지정 (immediate addressing mode) : 명령어의 피연산자 필드에 데이터가 포함되어 있으므로 주소 지정과는 상관이 없다. 따라서 명령어를 CPU로 인출만 하면 데이터가 바로 보이기 때문에 데이터를 즉시 이용할 수 있다. 
- 묵시 주소 지정 (implied addressing mode) : 누산기나 프로그램 계수기 등과 같은 정해진 기억장치에 데이터가 저장된다. 이 방식은 항상 정해진 장소에 데이터가 있기 때문에 데이터의 위치를 명시할 필요가 없다.

## 1-단계 주소 지정 방식

1-단계 주소 지정 방식은 데이터의 위치, 즉 유효 주소를 확정하기 위해 주소 계산이나 읽기 연산 과정을 한 번 수행하는 방식이다. 1-단계 주소 지정 방식부터는 데이터의 위치를 확정하기 위해 명령어의 피연산자 필드를 주소로 사용한다.

- 레지스터 직접 주소 지정 (register-direct addressing) : 데이터가 레지스터 파일 중의 한 곳에 있고 데이터가 있는 레지스터의 주소를 명령어의 피연산자 필드에 명시하는 방식이다. 이 방식은 높은 효율과 빠른 속도로 대부분의 아키텍처에서 사용된다. 이 방식의 데이터 주소 확정 과정은 다음과 같이 나타낼 수 있다.
  ea = r
- 직접 주소 지정 (direct addressing) : 데이터가 있는 메모리의 주소를 명령어의 피연산자 필드에 명시하는 방식이다. 데이터를 참조하려면 피연산자 필드에 명시된 메모리 주소를 사용하여 메모리에 접근하면 된다. 메모리 주소 공간 전체를 사용하려면 메모리의 절대 주소 길이 만큼 긴 피연산자 필드가 필요하므로 명령어가 너무 길어진다. 이 방식의 데이터 주소 확정 과정은 다음과 같이 나타낼 수 있다.
  ea = a

## 2-단계 주소 지정 방식

2-단계 주소 지정 방식은 데이터의 유효 주소를 확정하기 위해 주소 계산이나 읽기 연산 과정을 두 번 수행한다. 이 방식은 데이터가 메모리에 저장되므로 많은 데이터의 위치를 명시할 수 있다. 그러나 데이터의 주소를 확정하기 위해 2-단계 과정을 거쳐야 하므로 0-단계, 1-단계 주소 지정 방식보다 데이터를 참조하는 데 더 많은 시간이 걸린다.

- 레지스터 간접 주소 지정 (register-indirect addressing) :  피연산자 필드가 레지스터 주소를 명시하며, 레지스터의 내용이 데이터를 위한 메모리의 주소를 명시한다. 이 방식의 데이터 주소 확정 과정은 다음과 같이 나타낼 수 있다
  ea = Reg[r]
- 메모리 간접 주소 지정 (memory-indirect addressing) : 데이터가 있는 메모리 주소를 간접적으로 명령어의 피연산자 필드에 명시하는 방식이다. 이 방식의 데이터 주소 확정 과정은 다음과 같이 나타낼 수 있다
  ea = M[a]
- 변위 주소 지정 (displacement addressing): 명령어에 포함된 2개의 피연산자 필드를 사용하여 데이터가 있는 주소를 확정하는 방식이다. 이 방식의 데이터 주소 확정 과정은 다음과 같이 나타낼 수 있다.
  ea = Reg[r] + a
  이 방식은 색인 주소 지정과 베이트 주소 지정이 있다.
  - 색인 주소 지정 (indexed addressing) : 2개의 피연산자 필드 중 하나는 베이스 주소로 사용할 메모리 주소를 포함하고, 다른 하나는 변윗값으로 사용할 색인 레지스터 주소를 명시한다.
  - 베이스 주소 지정 (base addressing) : 2개의 피연산자 필드 중 하나는 베이스 주소로 사용할 베이스 레지스터 주소를 명시하고, 다른 하나는 변윗값으로 사용할 메모리 주소를 명시한다.

- PC 상대 주소 지정 (PC-relative addressing) : 베이스 레지스터로 프로그램 계수기를 사용하는 베이스 주소 지정의 특별한 경우에 해당되는데, 이 방식은 프로그램 계수기를 명시할 필요가 없으므로 변위 주소를 명시할 하나의 피연산자 필드만 있으면 된다. 이 방식의 데이터 주소 확정 과정은 다음과 같이 나타낼 수 있다
  ea = PC + a



# 복잡도에 따른 명령어 집합

## CISC의 탄생과 특징

## RISC의 탄생

## RISC의 특징

## RISC와 CISC의 전망



# picoMIPS 명령어 집합 구조

## picoMIPS의 개요

## picoMIPS의 명령어 형식과 종류

