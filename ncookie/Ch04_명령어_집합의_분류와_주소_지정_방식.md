# 피연산자의 수와 명령어 집합

명령어는 일반적으로 어떤 연산을 수행할 것인가를 나타내는 연산 부호와 연산될 데이터에 대한 정보를 포함하는 피연산자로 구성된다.

- 연산 부호 : 특별한 경우가 아니면 하나의 필드에 존재
- 피연산자
  - 여러 개의 필드로 구성될 수 있음
  - 내부에 명시적으로 나타난 피연산자의 수에 따라 0-주소 명령어(스택 컴퓨터), 1-주소 명령어(누산기 컴퓨터), 2-주소 명령어, 3-주소 명령어(범용 레지스터 컴퓨터) 등으로 분류됨

## 누산기 컴퓨터

**누산기 컴퓨터** : 메모리-메모리 컴퓨터에 하나의 데이터를 저장하기 위한 레지스터를 추가한 컴퓨터. 여기서 사용되는 레지스터를 누산기라고 함
  - 누산기를 묵시적 피연산자로 사용함
  - 적재 혹은 저장 명령어가 아니면 누산기는 근원지 겸 목적지 레지스터로 사용됨
  - 메모리를 명시적 피연산자로 사용함
  - CPU 내에 기억장치가 하나의 워드 용량인 누산기만 있으므로 단순하고 저렴함

> 메모리-메모리 컴퓨터와 비교하여 CPU에 누산기만 추가했을 뿐인데 폰노이만 병목에 대한 부담이 약 56.8%로 줄어들음
=> CPU 내부에 추가된 기억장치가 명령어 집합 설계에 큰 영향을 미침

## 스택 컴퓨터

**스택 컴퓨터** : CPU 내부에 다수의 데이터를 임시로 저장하기 위해 스택을 사용하는 컴퓨터
  - 스택에 저장된 모든 데이터는 위치에 따라 접근 시간이 다름
  - 대부분의 연산은 스택의 최상위 또는 차상위 데이터를 사용하여 수행
  - 최근 연산한 데이터는 스택의 최상위에 저장
  - *보관할 데이터의 양이 스택 용량보다 크면* 최하위에 있는 데이터부터 삭제해야 하므로 성능이 많이 떨어짐

> - 하나의 데이터만 저장할 수 있는 누산기 컴퓨터보다 폰노이만 병목에 대한 부담을 줄여줌
> - 스택의 특성 때문에 애플리케이션에 따라 누산기 컴퓨터보다 성능이 나쁠 수 있음

## 범용 레지스터 컴퓨터

**범용 레지스터 컴퓨터** : CPU 내부에 다수의 데이터를 임시로 저장하기 위해 범용 레지스터를 사용하는 컴퓨터
  - 스택과 달리 모든 레지스터의 접근 시간이 동일하며, 순서에 상관없이 임의로 접근할 수 있음
  - 레지스터가 명시적 피연산자로 사용됨

> - 다른 아키텍처에 비해 트래픽을 크게 감소시킴 
> => 오늘날의 컴퓨터는 범용 레지스터 컴퓨터 방식을 사용
> - 범용 레지스터의 수가 많으면 데이터에 대한 접근 시간이 짧아지고 메모리 트래픽이 줄어드는 효과가 있음
> - 범용 레지스터가 너무 많을 때의 문제 발생
>   - 레지스터 주소가 길어져 명령어의 길이도 늘어남
>   - 컴파일러가 모든 레지스터를 효과적으로 이용하기 어려움
>   - 문맥 교환 비용 증가
>   - 하드웨어 비용 상승


# 명령어와 메모리

## 메모리 속성

#### 워드
- 명령어와 데이터를 포함할 수 있는 메모리 구성 요소 중 하나
- 고정된 개수의 비트라는 메모리 소자로 이루어짐
- 최근에는 하나의 워드가 64비트인 컴퓨터가 많음

#### 주소
- 메모리는 주소라는 고유의 번호를 사용하여 명령어나 데이터를 참조함
- 큰 단위로 데이터를 다루면 주소가 짧아지지만 작은 단위의 데이터를 취급하기 어려움

#### 주소 지정 단위
- 그릇의 크기에 해당하며 주소 해상도를 결정함
- 아키텍처가 직접 명시할 수 있는 정보의 최소 단위

## 메모리 정렬

**정렬된 메모리**는 주소 해상도가 바이트라 할지라도 명령어와 데이터를 강제로 정렬하는 방식을 말한다. 대부분의 아키텍처는 명령어나 데이터를 정렬함으로써 성능을 높인다.

## 엔디언 방식

**엔디언**은 여러 개의 연속된 대상을 1차원 공간에 배열하는 방법을 말한다. 엔디언 방식에서 비트, 바이트, 워드의 순서는 어느 방법이든 성능에 차이가 없다고 알려져 있다. 그러나 컴파일된 실행 파일을 다른 아키텍처로 이식할 때는 워드 내부의 비트 혹은 바이트의 순서가 달라지기 때문에 의미가 있다.


# 주소 지정 방식

**주소 지정 방식**은 명령어의 일부인 피연산자 필드를 사용하여 데이터가 실제 위치한 유효 주소를 결정하는 방법이다. 피연산자 정보를 가지고 몇 단계를 거쳐 원하는 데이터에 접근할 수 있느냐에 따라 단계별로 분류할 수 있다.

명령어의 피연산자 필드와 데이터 실제 위치의 관계를 나타내기 위해 다음과 같은 표기를 사용한다.

- r : 명령어 내의 피연산자 필드가 명시하는 레지스터 주소
- a : 명령어 내의 피연산자 필드가 명시하는 메모리 주소
- ea : 참조되는 데이터를 포함하는 장소의 실제 주소, 즉 유효 주소
- Reg[x] : 레지스터 x의 내용
- M[x] : 메모리 x번지의 내용

## 0-단계 주소 지정 방식
- 데이터의 유효 주소를 명시하지 않음
- **즉치 주소 지정(immediate addressing mode)**
  - 명령어의 피연산자 필드에 데이터가 포함되어 있으므로 주소 지정과는 상관없음
  - 명령엉의 일부를 사용하므로 제한된 비트로 표현될 수 있는 작은 정수 데이터를 위한 공간으로 유용함
  - 명령어에 내장되어 있기 때문에 상수와 같이 변경하지 않는 데이터를 위해 사용
- **묵시 주소 지정(implied addressing mode)**
  - 누산기나 프로그램 계수기 등과 같은 정해진 기억장치에 데이터가 저장됨
  - 데이터를 사용하려면 하나의 기억장치를 읽어야하며, 많은 데이터에 대해 사용할 수 없음

## 1-단계 주소 지정 방식
- 데이터의 위치, 즉 유효 주소를 확정하기 위해 주소 계산이나 읽기 연산 과정을 한 번 수행하는 방식
- 명령어의 피연산자 필드를 주소로 사용
- **레지스터 직접 주소 지정(register-direct addressing)**
  - 데이터가 레지스터 파일 중의 한 곳에 있고 데이터가 있는 레지스터의 주소를 명령어의 피연산자 필드에 명시
  - 높은 효율과 빠른 속도로 대부분의 아키텍처에서 사용
  - 레지스터의 개수를 초과하는 데이터 집단을 취급할 때 효율적으로 사용하기 어려움
  - `ea = r`
- **직접 주소 지정(direct addressing)**
  - 데이터가 있는 메모리의 주소를 명령어의 피연산자 필드에 명시하는 방식
  - 오늘날에는 거의 사용하지 않음
  - `ea = a`

## 2-단계 주소 지정 방식
- 데이터의 유효 주소를 확정하기 위해 주소 계산이나 읽기 연산 과정을 두 번 수행
- 데이터가 메모리에 저장됨 -> 많은 데이터의 위치를 명시할 수 있음
- 0-단계 혹은 1-단계 주소 지정 방식보다 데이터를 참조하는데 더 많은 시간이 걸림
- **레지스터 간접 주소 지정(register-indirect addressing)**
  - 피연산자 필드가 레지스터 주소를 명시하며, 레지스터의 내용이 데이터를 위한 메모리의 주소를 명시
  - `ea = Reg[r]`
- **메모리 간접 주소 지정(memory-indirect addressing)**
  - 데이터가 있는 메모리의 주소를 간접적으로 명령어의 피연산자 필드에 명시하는 방식
  - 직접 주소 지정의 단점인 메모리 주소 공간이나 메모리 용량의 제약을 해결해주지만 두 번에 걸친 메모리 접근이 필요함
  - `ea = M[a]`
- **변위 주소 지정(displacement addressing)**
  - 명령어에 포함된 2개의 피연산자 필드를 사용하여 데이터가 있는 메모리의 주소를 확정하는 방식
  - `ea = Reg[r] + a`
  - 색인 주소 지정(indexed addressing) : 2개의 피연산자 필드 중 하나는 베이스 주소로 사용할 메모리 주소를 포함하고, 다른 하나는 변윗값으로 사용할 색인 레지스터 주소를 명시
  - 베이스 주소 지정(base addressing) : 2개의 피연산자 필드 중 하나는 베이스 주소로 사용할 베이스 레지스터 주소를 명시하고, 다른 하나는 변윗값으로 사용할 메모리 주소
- **PC 상대 주소 지정(PC-relative addressing)**
  - 베이스 레지스터로 프로그램 계수기를 사용하는 베이스 주소 지정의 특별한 경우에 해당됨
  - 프로그램 계수기를 명시할 필요가 없으므로 변위 주소를 명시할 하나의 피연산자 필드만 있으면 됨
  - `ea = PC + a`