# 컴퓨터의 세대별 발전

반도체 기술의 획기적인 발전에 따라 컴퓨팅 환경은 크게 진화하고 있음
- 1970년대 : 메인 프레임 시대, 단일 컴퓨터를 다수의 전문 사용자가 공유
- 1990년대 : 개인 컴퓨팅 시대, 하나의 컴퓨터를 한 사람이 전용
- 현재 : 유비쿼터스(Ubiquitous), 언제 어디서나 다수의 컴퓨터를 개인이 사용

## 컴퓨터의 세대별 특징 

| 세대  | 소자                  | 기억장치           |
| ---  | ---                   | ------------------ |
| 0세대 | 기계적 릴레이          | 금속 기어, 카드    |
| 1세대 | 진공관                 | 자기드럼           |
| 2세대 | 트랜지스터             | 자기코어           |
| 3세대 | SSI, MSI              | RAM, ROM           |
| 4세대 | LSI, VLSI             | SRAM, DRAM         |
| 5세대 | VLSI, ULSI, GLSI, SoC | SDRAM, DRAM, flash |

3세대 이후의 컴퓨터는 다수의 트랜지스터를 하나의 칩으로 집약한 **집적회로(IC, Intergrated Circuit)** 를 기반으로 함

5세대 컴퓨터는 자연어 처리, 지능형 컴퓨터, 전문가 시스템, 로봇, 종합 정보 통신망 등과 같은 분야에 사용됨


# 현대 컴퓨터 발전과 발전의 지표

## 폰노이만 아키텍처

폰노이만 모델은 1936년에 발표된 앨런 튜링의 유니버설 기계 모델을 구체화한 형태이다. 이전에는 고정결선식 프로그램 방식을 사용하였다.

- 고정결선식 프로그램 모델 
  - 미리 정의된 기능을 물리적 / 하드웨어적으로만 설계한 기계임
  - 처음 설계할 당시 설정한 기능 외에는 사용할 수 없음
- 프로그램 내장식 컴퓨터
  - 폰 노이만이 제안한 컴퓨팅 모델
  - 프로그램 자체와 프로그램에서 사용하는 데이터를 동일한 형태로 메모리에 저장할 수 있는 구조
  - 프로그램만 변경하면 데이터를 다양한 방식으로 처리할 수 있는 현대 범용 컴퓨터 개념의 시초 -> 소프트웨어의 개념을 탄생시킴


## 무어의 법칙

무어의 법칙은 인텔의 공동 창업자 고든 무어가 경험적 관찰에 의해 예측한 것으로, `단일 마이크로칩에 포함된 트랜지스터의 수가 18개월마다 약 2배씩 증가`한다는 것을 의미한다.

최근 많은 전문가들은 집적 기술이 이미 한계에 도달했기 때문에 무어의 법칙을 유지하기가 어려울 것으로 보며, 이를 **무어의 벽**이라고 한다.


# 컴퓨터의 성능

## 성능의 정의

컴퓨터의 성능은 사용하는 사람에 따라 응답 시간, 처리율 등을 기준으로 잡지만, 이 둘은 완전히 별개의 요소가 아니라 한 쪽이 향상되면 다른 쪽도 향상된다. 따라서 여기서는 사용자 관점의 성능인 응답 시간을 기준으로 한다.

- 응답 시간 : 하나의 프로그램을 처리하는데 소요되는 시간
- CPU 실행 시간 : 입출력이나 시분할 시스템 등에서 다른 프로그램의 실행 시간을 제외한 순수하게 사용된 시간

$$ 성능 = { 1 \over CPU 실행 시간 } $$
$$ M1에 대한 M2의 성능 비율 = n = { M2의 성능 \over M1의 성능 } = { M2의 실행 시간 \over M1의 실행시간 } $$

## 암달의 법칙

시스템의 일부분을 개선하는 경우 전체 시스템에서 얻을 수 있는 최대 성능 향상을 구할 때 사용한다. 주로 병렬화에 의한 시스템 성능 향상의 한계를 지적하는데 사용된다.

수식의 경우는 [다음 링크를 참고](https://ko.wikipedia.org/wiki/%EC%95%94%EB%8B%AC%EC%9D%98_%EB%B2%95%EC%B9%99)
암달의 법칙은 어떤 시스템을 개선하여 `전체 작업 중 P%의 부분에서 S배의 성능이 향상되었을 때 전체 시스템에서 최대 성능이 얼마나 향상되는지` 구하는 것이다.

예를 들어, 사칙연산을 수행하는 시스템에서 덧셈 및 뺄셈의 실행 시간이 2/3를 차지하고, 덧셈 및 뺄셈을 수행하는 가감산기의 성능을 개선한다고 할 때, 암달의 법칙에 따라 가감선기의 성능을 극한까지 개선한다고 해도 기존 시스템의 성능에서 3배 이상 개선할 수 없다.

이는 병렬화 등의 방법으로 시스템 일부의 성능을 개선함으로써 최적의 성능을 얻는 것도 좋지만 **성능이 개선되지 않는 부분을 최소화하는 것이 중요**하다는 점을 시사한다.


# CPU 성능 분석

## 성능에 영향을 미치는 요소

프로그램의 실행 시간은 다음과 같이 3개의 요소로 나타낼 수 있다.

$$ { CPU 실행 시간 \over 프로그램 } = { 명령어 개수 \over 프로그램 } \times { 사이클 개수 \over 명령어 } \times { 시간 \over 사이클 } $$

1. 프로그램의 크기 
    - 하나의 프로그램에 포함된 명령어 개수
    - 종류의 수가 아님
2. CPI(Cycles per Instruction)
   - 하나의 명령어를 실행하는데 필요한 클록 사이클의 수
   - CPI는 명령어마다 다를 수 있기 때문에 여기서는 평균 CPI를 사용
3. 사이클 시간
   - 한 클록 사이클에 소요되는 시간
   - 사이클 시간의 역수를 클록률 또는 클록 속도라고 함

CPU 실행 시간을 다시 정리하면 다음과 같다.

$$ 프로그램의 CPU 실행 시간 = 명령어 개수 \times 평균 CPI \times 사이클 시간 = { 명령어 개수 \times 평균 CPI \over 클록 속도 }$$

## 성능에 영향을 미치는 요소의 분석

컴퓨터 설계자는 프로그램의 크기, 평균 PCI, 프로세서 클록 사이클 이 세가지 요소를 모두 낮추려고 하지만, 서로 충돌하는 관계에 있다. 그리고 이들은 명령어 수준의 **아키텍처**, 컴퓨터의 구성과 관련된 **컴퓨터 구현**, 기술적 수준인 **컴퓨터 실현**에 의해 좌우된다.

아래 표는 성능에 영향을 미치는 요소 사이의 관계를 정리한 것이다.

| 구분                  | 명령어 개수 | 평균CPI | 클록 속도 |
| :---------------:     | :-----------: | :-------: | :---------: |
| 알고리즘              | O           |         |           |
| 아키텍처              | O           | O       | △         |
| 컴퓨터 구현           |             | O       | O         |
| 컴퓨터 실현           |             |         | O         |

#### 명령어 개수
  - 알고리즘과 아키텍처에 의해 결정
  - 개선 방법
    - 좋은 알고리즘을 사용
    - 강력하고 복잡한 명령어를 가진 아키처인 CISC(Complex Instrcution Set Computer) 구조를 사용
#### 평균 CPI
  - 아키텍처와 컴퓨터 구현에 의해 결정
  - 개선 방법
    - 단순한 명령어로 구성된 RISC(Reduced Instrcution Set Computer) 아키텍처를 사용
    - 병령화와 파이프라이닝 같은 고급 기술 등을 사용해 연산을 병렬로 구현
#### 클록 사이클 시간
  - 주로 컴퓨터 구현과 실현 수준에 의해 결정
  - 아키텍처도 영향을 줄 수 있음. 복잡한 명령어는 일반적으로 사이클 시간이 길어질 수 있기 때문
  - 컴퓨터 구현 수준
    - 데이터 경로가 짧으면 일반적으로 지연 시간이 짧아짐 -> 사이클 시간도 짧아짐
    - 파이프라이닝 기술 사용 -> 한 사이클 동안 수행할 작업 양 감소 -> 클록 속도 증가
  - 컴퓨터 실현 수준
    - 동일한 면적에 더 많은 트랜지스터를 집적할 수 있음 -> 클록 속도 향상
    - 따라서 반도체 제조 기술은 이 요소에 영향을 미침

따라서 시스템의 성능을 향상하기 위해 아키텍처, 컴퓨터 구현, 컴퓨터 실현 사이의 적절한 절충이 필요하다.


# 벤치마크와 성능 척도

## 벤치마크

두 시스템의 성능을 비교할 때 `작업 부하로 선택된 프로그램의 집합`을 **벤치마크**(Benchmark)라고 한다.

> TPC(Transaction Processing Performance Council)
> - 시스템의 성능 평가 척도를 마련하고 각 회사의 벤치마크 값을 검증하기 위해 발족한 비영리 단체
> - 네트워크 상의 여러 이용자가 실시간으로 데이터베이스의 데이터를 갱신하거나 조회하는 등의 단위 작업을 처리하는 시스템에 대한 성능을 평가

## MIPS와 MFLOPS

- IPS(Instructions per Second)
  - 컴퓨터의 프로세서 속도를 가늠하기 위한 척도
  - 1초 동안 실행한 명령어 개수를 의미함
- MIPS(Million Instructions per Second)
  - 1초에 수행한 명령어 개수를 100만으로 나눈 값
  - MIPS 값이 높으면 빠른 컴퓨터라고 할 수 있지만, 단순히 명령어 실행 속도를 나타내기 때문에 절대적이라고 할 수는 없음

$$ MIPS = { 명령어 개수 \over 실행시간 \times 10^6 } = { 클록 속도 \over CPI \times 10^6 }  $$

- MFLOPS(Million Floating Point Operations per Second)
  - 부동 소수점 연산의 수를 100만으로 나눈 값
  - 부동 소수점 연산은 프로그램에 종속적이며, MFLOPS 값은 정수와 부동 소수점 연산의 상대적 배합, 초월함수 등에 따라 달라질 수 있음
  - 위와 같은 이유들 때문에 성능을 비교하는데 적절하지 않은 경우가 흔하게 발생함

$$ MFLOPS = { 부동 소수점 연산 개수 \over 실행 시간 \times 10^6 } $$


### 의문
  - 현재 기업들은 시스템의 성능을 향상시키기 위해서 구체적으로 어떻게 요소들간 절충을 하고 있는가
  - 그렇다면 최근 벤치마크로 사용되는 기준 / 척도에는 어떤 것들이 있는가